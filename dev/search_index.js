var documenterSearchIndex = {"docs":
[{"location":"sites/#Sites","page":"Sites","title":"Sites","text":"","category":"section"},{"location":"sites/#General","page":"Sites","title":"General","text":"The state \"FullyMixed\" represents the infinite temperature mixed state, that is a density matrix proportional to the identity matrix.\n\nThere are seven predefined site types Qubit, Spin, Boson, Fermion, Electron, Tj and Qboson.","category":"section"},{"location":"sites/#Qubit","page":"Sites","title":"Qubit","text":"To use Qubit, call\n\nusing .Qubits","category":"section"},{"location":"sites/#Spins","page":"Sites","title":"Spins","text":"To use Spin, call\n\nusing .Spins","category":"section"},{"location":"sites/#Boson","page":"Sites","title":"Boson","text":"To use Boson, call\n\nusing .Bosons","category":"section"},{"location":"sites/#Fermion","page":"Sites","title":"Fermion","text":"To use Fermion, call\n\nusing .Fermions","category":"section"},{"location":"sites/#Electron","page":"Sites","title":"Electron","text":"To use Electron, call\n\nusing .Electrons","category":"section"},{"location":"sites/#Tj","page":"Sites","title":"Tj","text":"To use Tj, call\n\nusing .Tjs","category":"section"},{"location":"sites/#Qboson","page":"Sites","title":"Qboson","text":"To use Qboson, call\n\nusing .Qbosons","category":"section"},{"location":"sites/#Defining-new-site-types","page":"Sites","title":"Defining new site types","text":"To define a new site type, you need to define a new subtype of AbstractSite and define dim and possibly string_state on it (to overload do not forget to use the full name e.g. TensorMixedStates.dim). Then define its specific states and operators using @def_states and @def_operators. Don't forget to define the F operator for fermionic sites.","category":"section"},{"location":"sites/#TensorMixedStates.AbstractSite","page":"Sites","title":"TensorMixedStates.AbstractSite","text":"abstract type AbstractSite\n\nAn abstract type which is the super type of all site types\n\n\n\n\n\n","category":"type"},{"location":"sites/#NDTensors.dim-Tuple{AbstractSite}","page":"Sites","title":"NDTensors.dim","text":"dim(::AbstractSite)\n\nreturn the dimension of the given site\n\n\n\n\n\n","category":"method"},{"location":"sites/#ITensors.Index-Tuple{AbstractSite}","page":"Sites","title":"ITensors.Index","text":"Index(::AbstractSite)\n\nreturn an ITensor.Index for the given site for pure representations\n\n\n\n\n\n","category":"method"},{"location":"sites/#ITensors.SiteTypes.state-Tuple{AbstractSite, String}","page":"Sites","title":"ITensors.SiteTypes.state","text":"state(::AbstractSite, ::String)\n\nreturn the local state (as a vector or matrix) corresponding to the site and name given the special name \"FullyMixed\" gives the infinite temperature state\n\nExamples\n\njulia> using TensorMixedStates, .Qubits, .Fermions\n\njulia> state(Qubit(), \"+\")\n2-element Vector{Float64}:\n 0.7071067811865475\n 0.7071067811865475\n\njulia> state(Fermion(), \"FullyMixed\")\n2×2 Matrix{Float64}:\n 0.5  0.0\n 0.0  0.5\n\n\n\n\n\n","category":"method"},{"location":"sites/#TensorMixedStates.Id","page":"Sites","title":"TensorMixedStates.Id","text":"Id\n\nthe identity operator defined for all site types\n\n\n\n\n\n","category":"constant"},{"location":"sites/#TensorMixedStates.F","page":"Sites","title":"TensorMixedStates.F","text":"F\n\nthe Jordan Wigner F factor. Defined for all site types\n\n\n\n\n\n","category":"constant"},{"location":"sites/#TensorMixedStates.Qubit","page":"Sites","title":"TensorMixedStates.Qubit","text":"type Qubit\n\nA site type for representing qubit sites, that is a two level system.\n\nExample\n\nQubit()\n\nStates\n\n\"Up\", \"Z+\", \"↑\", \"0\"  : the up state\n\"Dn\", \"Z-\", \"↓\", \"1\"  : the down state\n\"+\", \"X+\"             : the + state (+1 eigenvector of X)\n\"-\", \"X-\"             : the - state (-1 eigenvector of X)\n\"i\", \"Y+\"             : the i state (+1 eigenvector of Y)\n\"-i\", \"Y-\"            : the -i state (-1 eigenvector of Y)\n\nOperators\n\nX, Y, Z          : the Pauli operators\nSp, Sm           : the S^+ and S^- operators\nSx, Sy, Sz, S2   : the S_x, S_y, S_z operators (half the Pauli operators) and S^2\nH, S, T, Swap    : the Hadamard, S, T and Swap gates\nPhase(t)         : the phase gate\ncontrolled(gate) : controlled gate\n\n\n\n\n\n","category":"type"},{"location":"sites/#TensorMixedStates.Phase","page":"Sites","title":"TensorMixedStates.Phase","text":"Phase(t)\n\nthe phase gate for qubits\n\n\n\n\n\n","category":"function"},{"location":"sites/#TensorMixedStates.controlled","page":"Sites","title":"TensorMixedStates.controlled","text":"controlled(op)\n\nthe controlled gate constructor\n\nExamples\n\nCZ = controlled(Z)\nToffoli = controlled(controlled(X))\n\n\n\n\n\n","category":"function"},{"location":"sites/#TensorMixedStates.graph_state","page":"Sites","title":"TensorMixedStates.graph_state","text":"graph_state(graph::Vector{Tuple{Int, Int}}; limits)\n\ncreate a graph state corresponding to the given graph\n\nExamples\n\ngraph_state(complete_graph(10); limits = Limits(maxdim = 10))\n\n\n\n\n\n","category":"function"},{"location":"sites/#TensorMixedStates.create_graph_state","page":"Sites","title":"TensorMixedStates.create_graph_state","text":"create_graph_state(graph::Vector{Tuple{Int, Int}}; limits)\n\ncreate a phase for building a graph state to use in SimData and runTMS\n\n\n\n\n\n","category":"function"},{"location":"sites/#TensorMixedStates.Spin","page":"Sites","title":"TensorMixedStates.Spin","text":"Spin(spin)\n\nA site type for representing spin sites (dim is 2 spin + 1)\n\nExample\n\nSpin(3/2)\nSpin(2)\n\nStates\n\n\"0\", \"1\", \"-1\"... for integer spins \"1/2\", \"-1/2\", \"3/2\", \"-3/2\"... for half integer spins\n\n\"X0\", \"X1/2\", \"X-1/2\", ... for eigenstate of Sx \"Y0\", \"Y1/2\", \"Y-1/2\", ... for eigenstate of Sy \"Z0\", \"Z1/2\", \"Z-1/2\", ... for eigenstate of Sz (same as \"0\", \"1/2\" ...)\n\nOperators\n\nSp, Sm           : the S^+ and S^- operators\nSx, Sy, Sz, S2   : the S_x, S_y, S_z operators and S^2\n\n\n\n\n\n","category":"type"},{"location":"sites/#TensorMixedStates.Boson","page":"Sites","title":"TensorMixedStates.Boson","text":"Boson(dim)\n\na site type to represent boson sites, it is parametred by the dimension of the Hilbert space (maximum occupancy is dim - 1)\n\nExamples\n\nBoson(4)\n\nStates\n\n\"0\", \"1\", ...\n\nOperators\n\nA : the destruction operator\nN : the number of bosons operator\n\n\n\n\n\n","category":"type"},{"location":"sites/#TensorMixedStates.Fermion","page":"Sites","title":"TensorMixedStates.Fermion","text":"Fermion()\n\na site type to represent fermion sites (dim is 2)\n\nExamples\n\nFermion()\n\nStates\n\n\"0\", \"Emp\" : empty state\n\"1\", \"Occ\" : occupied state\n\nOperators\n\nC : the destruction operator\nA : the Jordan-Wigner transform of C (...C = FFFA)\nN : the number of fermions operator\n\n\n\n\n\n","category":"type"},{"location":"sites/#TensorMixedStates.Electron","page":"Sites","title":"TensorMixedStates.Electron","text":"Eletron()\n\na site type to represent electron sites (dim is 4)\n\nExamples\n\nElectron()\n\nStates\n\n\"0\", \"Emp\"   : empty state\n\"Up\", \"↑\"    : up state\n\"Dn\", \"↓\"    : down state\n\"UpDn\", \"↑↓\" : up and down state\n\nOperators\n\nCup, Cdn              : the destruction operators\nAup, Adn              : the Jordan-Wigner transforms of Cup and Cdn (...C = FFFA)\nNup, Ndn, Nupdn, Ntot : the numbers operator for up, down, up and down, and total\nSx, Sy, Sz, Sp, Sm    : spin operators\nFup, Fdn              : partial Jordan-Wigner F operators\n\n\n\n\n\n","category":"type"},{"location":"sites/#TensorMixedStates.Tj","page":"Sites","title":"TensorMixedStates.Tj","text":"Tj()\n\na site type to represent Tj sites (like Electron sites without the up and down state, dim is 3)\n\nExamples\n\nElectron()\n\nStates\n\n\"0\", \"Emp\"   : empty state\n\"Up\", \"↑\"    : up state\n\"Dn\", \"↓\"    : down state\n\nOperators\n\nCup, Cdn              : the destruction operators\nAup, Adn              : the Jordan-Wigner transforms of Cup and Cdn (...C = FFFA)\nNup, Ndn, Ntot        : the numbers operator for up, down and total\nSx, Sy, Sz, Sp, Sm    : spin operators\nFup, Fdn              : partial Jordan-Wigner F operators\n\n\n\n\n\n","category":"type"},{"location":"sites/#TensorMixedStates.Qboson","page":"Sites","title":"TensorMixedStates.Qboson","text":"Qboson(q, dim)\n\na site type to represent q-boson sites, it is parametred by q and the dimension of the Hilbert space (maximum occupancy is dim - 1).\n\nanrangle = sqrt1-q^n n-1rangle and a^dagger nrangle = sqrt1 - q^n+1 n+1rangle\n\nExamples\n\nQboson(0.1, 4)\n\nStates\n\n\"0\", \"1\", ...\n\nOperators\n\nA : the destruction operator\nN : the number of q-bosons operator\n\n\n\n\n\n","category":"type"},{"location":"sites/#TensorMixedStates.string_state","page":"Sites","title":"TensorMixedStates.string_state","text":"string_state(::AbstractSite, ::String)\n\nDo not call directly. It returns a local state corresponding to the string, this is tried first before trying specifically defined states.\n\nThe default implementation returns the first state for \"0\", the second for \"1\" and so on.\n\nThis should be overloaded if necessary when defining new site types. It should return an error when not needed.\n\n\n\n\n\n","category":"function"},{"location":"sites/#TensorMixedStates.@def_states","page":"Sites","title":"TensorMixedStates.@def_states","text":"@def_states(site, symbols)\n\ndefine the given states for the given site\n\nExample\n\n@def_states(Fermion(),\n[\n    [\"Emp\", \"0\"] => [1., 0.],\n    \"Occ\" => [0., 1.],\n])\n\n\n\n\n\n","category":"macro"},{"location":"sites/#TensorMixedStates.@def_operators","page":"Sites","title":"TensorMixedStates.@def_operators","text":"@def_operators(site, symbols)\n\ndefine the given operators for the given site, see also OpType\n\nExamples\n\n@def_operators(Fermion(),\n[\n    fermionic_op => \n    [\n        C = [0. 1. ; 0. 0.],\n    ],\n    selfadjoint_op =>\n    [\n        N = dag(C) * C,\n    ],\n    plain_op =>\n    [\n        A = C,\n    ],\n    involution_op =>\n    [\n        F = Float64[1 0 ; 0 -1]\n    ]\n])\n\n\n\n\n\n","category":"macro"},{"location":"operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"operators/#Usage","page":"Operators","title":"Usage","text":"There are two kinds of operators: generic (like X) and indexed (like X(3)). Indexed operators are applied to specific site numbers.\n\nOperators can be used to defined Hamiltonians, for example\nhamiltonian = - j * sum(X(i)X(i+1) + Y(i)Y(i+1) for i in 1:n-1) - h * sum(Z(i) for i in 1:n)\n\nor Lindbladian dissipators like\n\ndissipators = sum(Dissipator(Sp)(i) for i in 1:n)\n\nto build Lindbladian\n\nlindbladian = -im * hamiltonian + dissipators\n\nNote the factor -im for the Hamiltonian.\n\nOperators can be used to define quantum gates like\ngates = H(1)Swap(1, 2)H(1)\n\nNoisy gates can be defined using the Gate constructor, for example\n\nnoisygate = 0.7Gate(Id) + 0.1Gate(X) + 0.1Gate(Y) + 0.1Gate(Z)\n\nOperators can be used to define observables\nobs = X(1)X(2)Z(3)","category":"section"},{"location":"operators/#Reference","page":"Operators","title":"Reference","text":"Complex operators can be build from a rich set of functions, for example\n\nRxy(t) = exp(-im * t * (X⊗X + Y⊗Y) / 4)\n\nOperators can be added and multiplied using usual operators (+, -, *, /, ^).","category":"section"},{"location":"operators/#TensorMixedStates.Pure","page":"Operators","title":"TensorMixedStates.Pure","text":"type Pure <: PM\nPure()\n\ncorrespond to pure quantum representation\n\n\n\n\n\n","category":"type"},{"location":"operators/#TensorMixedStates.Mixed","page":"Operators","title":"TensorMixedStates.Mixed","text":"type Mixed <: PM\nMixed()\n\ncorrespond to mixed quantum representation\n\n\n\n\n\n","category":"type"},{"location":"operators/#TensorMixedStates.Op","page":"Operators","title":"TensorMixedStates.Op","text":"Op{R <: PM, T <: GI, N}\n\nthe type of all operators.\n\nType parameters\n\nR: is Pure or Mixed (the type of the representations on which the operator may be applied)\nT: ig Generic or Indexed\nN: the number of sites on which the operator must be applied (set to 1 for indexed operators)\n\n\n\n\n\n","category":"type"},{"location":"operators/#TensorMixedStates.Operator","page":"Operators","title":"TensorMixedStates.Operator","text":"type Operator{N} <: GenericOp{Pure, N}\n\nthe type of base operators (like X, Swap, C ...), N is the number of sites on which it may be applied.\n\nExample\n\nOperator{1}(\"X\", Nothing, involution_op)     a base operator whose value is predefined by the sites\nOperator{1}(\"Z\", [1 0 ; 0 -1], involution_op)\nOperator{2}(\"Swap\", [ 1 0 0 0 ; 0 0 1 0 ; 0 1 0 0 ; 0 0 0 1], involution_op)\nOperator{1}(\"Sx\", (Sp + Sm) / 2, selfadjoint_op)\nOperator{1}(\"C\", [0 1 ; 0 0], fermionic_op)\n\n\n\n\n\n","category":"type"},{"location":"operators/#TensorMixedStates.AtIndex","page":"Operators","title":"TensorMixedStates.AtIndex","text":"struct AtIndex{R, N} <: IndexedOp{R}\n\nrepresent an indexed operator (like X(1) or Swap(2, 4))\n\n\n\n\n\n","category":"type"},{"location":"operators/#TensorMixedStates.:⊗","page":"Operators","title":"TensorMixedStates.:⊗","text":"op1 ⊗ op2\n\ntensor product for generic operators, alternative syntax: tensor(op1, op2)\n\nExamples\n\ncontrolled(op) = Proj(\"Up\") ⊗ Id + Proj(\"Dn\") ⊗ op\nRxy(t) = exp(im * t * (X ⊗ X + Y ⊗ Y) / 4)\n\n\n\n\n\n::System ⊗ ::System\ntensor(::System, ::System)\n\ncreate the tensorial product of two systems\n\n\n\n\n\n","category":"function"},{"location":"operators/#TensorMixedStates.Proj","page":"Operators","title":"TensorMixedStates.Proj","text":"Proj(state)\n\nan operator to project on the given state\n\nExamples\n\nProj(\"Up\")\nProj([1, 0])\n\n\n\n\n\n","category":"type"},{"location":"operators/#TensorMixedStates.Dissipator","page":"Operators","title":"TensorMixedStates.Dissipator","text":"Dissipator(op)\n\na Lindbladian dissipator based on op to be used in evolver for time evolution\n\nExamples\n\nDissipator(Sp)\nDissipator(0.1 * C)\nDissipator(Z ⊗ Z)\nDissipator(0.9X⊗Sm⊗X + 0.1Y⊗Sm⊗Y)\n\n\n\n\n\n","category":"type"},{"location":"operators/#TensorMixedStates.Gate","page":"Operators","title":"TensorMixedStates.Gate","text":"Gate(op)\n\na generic operator acting as a gate on states in mixed representation. Usefull for building noisy gates\n\nExamples\n\nG = 0.9 * Gate(Id) + 0.1 Gate(X)\n\n\n\n\n\n","category":"type"},{"location":"operators/#ITensors.dag-Tuple{GenericOp{Pure}}","page":"Operators","title":"ITensors.dag","text":"dag(::GenericOp)\n\nadjoint for generic operators\n\n\n\n\n\n","category":"method"},{"location":"operators/#TensorMixedStates.isfermionic","page":"Operators","title":"TensorMixedStates.isfermionic","text":"isfermionic(::GenericOp)\n\nreturn whether a generic operator is fermionic \n\n\n\n\n\n","category":"function"},{"location":"operators/#NDTensors.matrix","page":"Operators","title":"NDTensors.matrix","text":"matrix(a::GenericOp, site::AbstractSite...)\n\nreturn the matrix of a generic operator for the given sites. If sites are all identical, you may give only one\n\nExamples\n\nmatrix(X, Qubit())\nmatrix(Swap, Qubit())\nmatrix(X⊗A, Qubit(), Boson(2))\n\n\n\n\n\n","category":"function"},{"location":"operators/#TensorMixedStates.tensor","page":"Operators","title":"TensorMixedStates.tensor","text":"tensor(a::GenericOp, site::AbstractSite...)\n\nreturn the ITensor of a generic operator for the given sites. If sites are all identical, you may give only one\n\nExamples\n\ntensor(X, Qubit())\ntensor(Swap, Qubit())\ntensor(X⊗A, Qubit(), Boson(2))\n\n\n\n\n\ntensor(::System, ::AtIndex)\n\nreturns a tensor representing the given simple indexed operator acting on this system\n\n\n\n\n\n","category":"function"},{"location":"operators/#TensorMixedStates.simplify","page":"Operators","title":"TensorMixedStates.simplify","text":"simplify(op::Op; expand=false)\n\nsimplifies an operator, this is used internally by functions creating MPOs. expand tells wheteher to expand explicit operators with their definition\n\n\n\n\n\n","category":"function"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/#Import","page":"Manual","title":"Import","text":"To use TMS, you must first import it with\n\nusing TensorMixedStates","category":"section"},{"location":"manual/#Sites-and-Systems","page":"Manual","title":"Sites and Systems","text":"The first step in using TMS is the definition of your quantum system. In TMS, a system is composed of a finite number of sites numbered from 1 (1, 2, ..., N). These sites may be all identical or not.\n\nThere are seven different predefined types of site: Qubit, Fermion, Boson, Spin, Electron, Tj and Qboson.\n\nTo use each of these sites and the corresponding predefined operators you need first to import the corresponding module. For example to use qubits, you need to write\n\nusing .Qubits\n\nNote the \".\" before the name and the \"s\" at the end.\n\nTo define a site just call the corresponding creator for example\n\ns = Qubit()\n\nSome site creators need arguments: Boson (for the maximum dimension) and Spin, for example\n\ns = Boson(4)\ns = Spin(3/2)\n\nYou can now define a quantum system by declaring the sites it contains:\n\nsystem1 = System(10, Qubit())\n\ngives you a system with 10 qubits. Systems may have different types of site, in this case you must feed System with an array of sites\n\nsystem2 = System([Qubit(), Boson(4), Fermion()])\n\ngives you a three site system.","category":"section"},{"location":"manual/#States","page":"Manual","title":"States","text":"States may be in pure or mixed representation, these two possibilities are represented in TMS, by Pure or Mixed.\n\nTo create a state, we call the State creator\n\nstate1 = State{Pure}(system1, \"Up\")\n\nreturns a pure up state in a 10 qubit system. Predefined local states are designated by their name. Here \"Up\" is a predefined state of site Qubit.\n\nAll sites need not be all in the same local states, in which case we give State an array of local states\n\nstate2 = State{Mixed}(system2, [\"+\", \"2\", \"Occ\"])\n\nHere we choose a mixed representation.\n\nStates may be added or multiplied by a number (they need to be based on the same system). For example\n\nghz = (State{Pure}(system1, \"Up\") + State{Pure}(system1, \"Dn\")) / 2\n\nWe can transform a pure representation into a mixed representation by\n\nmixedstate = mix(purestate)\n\nFor mixed states there is a local mixed state \"FullyMixed\" which correspond to a density matrix proportional to the identity matrix (that is the infinite temperature state).\n\nIf you need a local state which is not predefined, it is possible to pass its vector (or matrix for mixed states) directly, For example, we could also define state1 by\n\nstate1 = State{Pure}(system1, [1., 0.])","category":"section"},{"location":"manual/#Limits","page":"Manual","title":"Limits","text":"TMS uses Matrix Product State to internally represent quantum states. It is important to control the parameters of this approximation, in particular the maximum bond dimension and the cutoff on singular values. To achieve this, many functions accept a Limits object as keyword argument containing those parameters. It is build thus\n\nlim = Limits(cutoff = 1e-10, maxdim = 50)\n\neach (or both) of the arguments may be omitted in which case it corresponds to an absence of constraint for this parameter. In particular, Limits() represents no constraint.\n\nTo apply the constraints on a state, one uses\n\nnewstate = truncate(oldstate; limits = lim)\n\nMany functions accept such an argument. For example, when adding states instead of\n\nstate = (state1 + state2) / 2\n\nOne can write\n\nstate = +(state1, state2; limits = lim) / 2","category":"section"},{"location":"manual/#Operators","page":"Manual","title":"Operators","text":"In TMS, there are two kinds of operators: generic operators and indexed operators. For example,\n\nX\n\nrepresents the sigma_x Pauli operator for qubits. This is a generic operator, it is not applied to a specific site.\n\nX(3)\n\nrepresents the sigma_x Pauli operator applied to the system site number 3. This is an indexed operator.\n\nNote that all predefined operator names start with a capital letter, so it is better to keep your own identifiers lowercase to prevent name collisions.\n\nThe operator system is very rich and flexible. For example, if you want to use this Hamiltonian\n\nH = sum_i=1^n-1 sigma_x(i) sigma_x(i+1)\n\nyou will simply write\n\nh = sum(X(i)X(i+1) for i in 1:n-1)\n\nMany operations are defined on generic operators:\n\naddition, multiplication and power by a number\ntensor product: X⊗X is a two site operator (⊗ is usually obtained by typing \\otimes in your editor, just in case, one can also write tensor(X, X))\ndag represents the adjoint operator, for example C is the c operator for fermions and dag(C) is c^dagger.\nDissipator represents a Lindblad dissipator, for example Dissipator(Sp) is the jump operator that may flip a qubit toward up (Sp is the S^+ operator)\nGate represents an operator to be applied as a gate on a mixed state. It is useful to define noisy gate operators, for example 0.9 Gate(Id) + 0.1 Gate(X) is a noisy gate operator that will apply an sigma_x gate 10 percent of the time.\nProj represents an operator that projects on the given state, for example Proj(\"Up\") projects qubits on the up state.\nthe functions exp and sqrt: for example sqrt(Swap)\ncontrolled for qubits makes controlled gates: CX = controlled(X)\n\nFor example one can define the Rxy 2-site operator by\n\nRxy(t) = exp(-im * t * (X⊗X + Y⊗Y) / 4)\n\nIf this is not enough to define your favorite operator you can create new ones by specifying their matrix. The number in braces is the number of sites on which the operator must be applied.\n\nmyop = Operator{1}(\"MyOp\", [1 1 ; 1 -1] / √2, involution_op)\n\nSwap = Operator{2}(\"Swap\", [1 0 0 0 ; 0 0 1 0 ; 0 1 0 0 ; 0 0 0 1])\n\nFinally from generic operators, we define indexed operators by simply applying them to the corresponding sites\n\nRxy(0.2)(2, 5)\nmyop(3)\nSwap(4, 7)\n\nIn the case of Hamiltonian or Lindbladian evolution the Hamiltonian part is to be multiplied by -im:\n\nevolver = -im * hamiltonian + dissipators","category":"section"},{"location":"manual/#Algorithms","page":"Manual","title":"Algorithms","text":"We can now work with states and operators.\n\nWe can apply gates with apply\n\nnewstate = apply(gates, oldstate; limits)\n\nthe gates argument is an indexed operator representing the gates to apply\n\nthe keyword argument limits fixes the constraints to apply\n\nWe can compute ground states with dmrg\n\ngroundstate, energy = dmrg(hamiltonian, startstate; options...)\n\nthe options are limits to set constraints and nsweeps to fix the number of sweeps among others.\n\nWe can do time evolution with tdvp and approx_W\n\nnewstate = tdvp(evolver, time, oldstate; options...)\nnewstate = approx_W(evolver, time, oldstate; options...)\n\nthe options are limits for the constraints, nsweeps for the number of step to do and for approx_W, order and w for the parameters of the algorithm (order = 4, w = 2 are usually good)\n\nFor more details, see the reference or the inline help.","category":"section"},{"location":"manual/#Measurements","page":"Manual","title":"Measurements","text":"Once we have created a state, we may want to measure it.\n\nresult = measure(state, X(1)X(3))\n\nwill give langle psi  sigma_x^1 sigma_x^3  psi rangle\n\nresult = measure(state, X)\n\nwill give the array of the langle psi  sigma_x^i  psi rangle\n\nresult = measure(state, (X, Y))\n\nwill give the matrix of the langle psi  sigma_x^i sigma_y^j  psi rangle\n\nWe can also measure other properties with\n\nTrace : the trace of the density matrix, this should be one, so it is a good indicator for accumulated error\nTraceError: measure the deviation from trace 1\nTrace2, Purity: measure the trace of the square of the density matrix\nHermitianity: measure how well the density matrix is Hermitian, return 1 if Hermitian, 0 if antihermitian\n\nor any value in between\n\nHermitianityError measure the deviation from hermitianity 1\nRenyi2: measure the Renyi entropy of order 2 of the system\nSubRenyi2: measure the Renyi entropy of order 2 of a subsystem\nEE: entanglement entropy for pure representation, OSEE for mixed\nLinkdim: the maximum bond dimension of the representation\nMemoryUsage: the memory used to store the representation\n\nWe can also ask for several measurements at the same time\n\nresults = measure(state, [X, X(2)Z(3), (X, Y), Trace, MemoryUsage])\n\nFor more details see the reference or the inline help.","category":"section"},{"location":"manual/#High-Level-Interface","page":"Manual","title":"High Level Interface","text":"","category":"section"},{"location":"manual/#Framework","page":"Manual","title":"Framework","text":"Most simulations follow the same pattern: start from some simple state, make some evolution and make measurements during or after the evolution and save the results to file. For these simple cases, TMS presents a simpler interface.\n\nA simple simulation follows a single state through a certain number of phases which act in a simple way on the state and make measurements during and/or after the evolution and save the results to file.\n\nThe following phases are available:\n\nCreateState : create a simple state\nGroundState : compute the ground state using dmrg (requires a pure state)\nToMixed : go from pure representation to mixed representation\nEvolve : do Hamiltonian or Lindbladian evolution\nGates : apply some gates\nPartialTrace : trace the system over some sites (requires a mixed state)\nSteadyState : compute the steady state of a Lindblad equation (still experimental, requires a mixed state)\n\nwith these phases we define a SimData object that describes the simulation and finally, we call\n\nrunTMS(simdata)\n\nwhich executes the simulation.","category":"section"},{"location":"manual/#Example","page":"Manual","title":"Example","text":"As an example, here is the complete code for such a simple simulation:\n\nusing TensorMixedStates, .Fermions\n\nhamiltonian(n) = -sum(dag(C)(i)C(i+1)+dag(C)(i+1)C(i) for i in 1:n-1)\ndissipators(n, gamma) = sum(Dissipator(sqrt(4gamma) * N)(i) for i in 1:n)\n\nsim_data(n, gamma, step) = SimData(\n    name = \"Fermion tight-binding chain with dephasing noise\",\n    phases = [\n        CreateState(\n            type = Mixed(),\n            sytem = System(n, Fermion()),\n            state = [ iseven(i) ? \"Occ\" : \"Emp\" for i in 1:n ]),\n        Evolve(\n            duration = 4,\n            time_step = step,\n            algo = Tdvp(),\n            evolver = -im*hamiltonian(n) + dissipators(n, gamma),\n            limits = Limits(cutoff = 1e-30, maxdim = 100),\n            measures = [\n                \"density.dat\" => N,\n                \"OSEE.dat\" => EE(div(n, 2))\n            ]\n        )\n    ]\n)\n\nrunTMS(sim_data(40, 1., 0.05))","category":"section"},{"location":"manual/#Output","page":"Manual","title":"Output","text":"runTMS creates a directory named after the SimData object name field and puts the output files there. In particular, it produces a log file showing the progression of the computation, a prog.jl file containing a copy of the script, a description file containing the content of the SimData description field, a stamp file containing version and date info, a running empty file is present during the computation, in case of error an empty error file is created.\n\nThree keyword arguments may be given restart (default true) erases the directory before starting, clean (default false) erases the directory and does not run the simulation, output (default nothing) if set, does not create the directory nor any output files an redirect all output to the given io channel (useful values are stdout and devnull). \n\nMeasurements are specified in the measures or final_measures fields. They take the form of a pair or list of pairs.\n\nmeasures = destination => measurements\nmeasures = [ dest1 => meas1, dest2 => meas 2, ...]\n\nThe possible measurements are described in the measurements section of this manual. There are three types of destinations:\n\nfilenames: writes the specified measurements to the given file as they are made. Special filenames are \"stdout\" (or \"-\"), \"stderr\", \"\" (for devnull)\n\"file.dat\" => X\njson filenames: filenames ending by \".json\" are treated differently: data is accumulated during the simulation and written at the end in the JSON format.\n\"file.json\" => [Purity, X(2)Z(3), (X, Y)]\nData object: data is accumulated during the simulation and stored in the data field of the Simulation object returned by runTMS. This is useful for analyzing the data inside the program.\nData(\"mydata\") => [TraceError, X(1), Y]\n\nThe DataToFrame function can used on the result to get a DataFrame object (the user must import the DataFrames package himself before using this function)\n\nsim = runTMS(simdata)\ndf = DataToFrame(sim.data[\"mydata\"])\n\nFor more information, see the reference or inline help for each phase, SimData and runTMS.","category":"section"},{"location":"others/#Others","page":"Others","title":"Others","text":"","category":"section"},{"location":"others/#Graphs","page":"Others","title":"Graphs","text":"graphs are useful to describe interactions or gates to apply ","category":"section"},{"location":"others/#MPO","page":"Others","title":"MPO","text":"Matrix Product Operators (MPO) are used under the hood by TMS to operate on MPS (inner state representation). Except for apply and measure all operators are converted to MPO internally.","category":"section"},{"location":"others/#Time-dependent-operators","page":"Others","title":"Time dependent operators","text":"For time evolution, it may be useful to have time dependent operators. In TMS, a time dependent operator is described in the following way: a vector of indexed operators and a vector of time functions. For example, to describe\n\n    h(t) = - e^-t sum_i=1^n-1 sigma_x^i sigma_x^i+1 - sin(t) sum_i=1^n sigma_z^i  \n\nwe use\n\nhs = -im * [ -sum(X(i)X(i+1) for i in 1:n-1), -sum(Z(i) for i in 1:n)]\n\nand\n\ncoefs = [ t -> exp(-t), t -> sin(t) ]\n\nh is passed as usual to tdvp or approx_W and coefs is passed as a keyword argument called coefs. When using Simulation the simulation time is used for t, for State the initial simulation time is passed as a keyword argument called time_start (which default to 0)\n\ntdvp(hs, duration, initial_state; coefs, time_start)\n\nWith the high level interface, one can use time dependent evolver for the Evolve phase with the following syntax\n\nevolver = hs => coefs","category":"section"},{"location":"others/#TensorMixedStates.line_graph","page":"Others","title":"TensorMixedStates.line_graph","text":"line_graph(n)\n\nreturn the graph 1-2, 2-3, ..., (n-1)-n\n\n\n\n\n\n","category":"function"},{"location":"others/#TensorMixedStates.circle_graph","page":"Others","title":"TensorMixedStates.circle_graph","text":"circle_graph(n)\n\nreturn the graph 1-2, 2-3, ..., (n-1)-n, n-1\n\n\n\n\n\n","category":"function"},{"location":"others/#TensorMixedStates.complete_graph","page":"Others","title":"TensorMixedStates.complete_graph","text":"complete_graph(n)\n\nreturn the complete graph with n vertices 1-2, 1-3, 2-3, 1-4, 2-4, 3-4 ...\n\n\n\n\n\n","category":"function"},{"location":"others/#TensorMixedStates.graph_base_size","page":"Others","title":"TensorMixedStates.graph_base_size","text":"graph_base_size(::Vector{Tuple{Int, Int}})\n\nreturn the maximum vertex number in a graph\n\n\n\n\n\n","category":"function"},{"location":"others/#TensorMixedStates.PreMPO","page":"Others","title":"TensorMixedStates.PreMPO","text":"PreMPO(::State, op)\n\npreprocess an operator (or vector of operators). The result can be passed wherever an operator that must be turned into an MPO is expected\n\n\n\n\n\n","category":"type"},{"location":"others/#TensorMixedStates.make_mpo","page":"Others","title":"TensorMixedStates.make_mpo","text":"make_mpo(::PreMPO[, coefs])\nmake_mpo(::State, operator)\n\nbuild an mpo representing an operator\n\n\n\n\n\n","category":"function"},{"location":"others/#TensorMixedStates.make_approx_W1","page":"Others","title":"TensorMixedStates.make_approx_W1","text":"make_approx_W1(::PreMPO, tau[, coefs])\nmake_approx_W1(::State, operator, tau)\n\nbuild MPO representing approximation WI of a given operator and time step\n\n\n\n\n\n","category":"function"},{"location":"others/#TensorMixedStates.make_approx_W2","page":"Others","title":"TensorMixedStates.make_approx_W2","text":"make_approx_W2(::PreMPO, tau[, coefs])\nmake_approx_W2(::State, operator, tau)\n\nbuild MPO representing approximation WII of a given operator and time step\n\n\n\n\n\n","category":"function"},{"location":"highlevel/#High-level-interface","page":"High level interface","title":"High level interface","text":"","category":"section"},{"location":"highlevel/#TensorMixedStates.runTMS","page":"High level interface","title":"TensorMixedStates.runTMS","text":"runTMS(::SimData)\nrunTMS(::SimData; clean = true)\nrunTMS(::SimData; restart = true)\nrunTMS(::SimData; output = myoutput)\n\nrun the given simulation (see SimData for details), write the output to file and return a Simulation object containing the result. clean (default false) remove the simulation directory and exit, restart (default false) remove the simulation directory and run the simulation, output redirect all output to the given IO channel (no output directory created), usefull values are stdout or devnull (to suppress all output).\n\n\n\n\n\n","category":"function"},{"location":"highlevel/#TensorMixedStates.SimData","page":"High level interface","title":"TensorMixedStates.SimData","text":"SimData(name = \"my_simulation\", phases::Vector{Phases} = [phase1, phase2...])\n\nA type for describing a simulation to use with runTMS\n\nFields\n\nname:            the name of the simulation used as the name of the directory to store the results\nphases:          the list of phases of the simulation (see Phases for a list of possible values)\ndescritpion:     text put in the description file of the simulation (default \"\")\ntime_start:      initial simulation time (default 0.)\nfinal_measures:  measures to make at the end of simulation (default []) see measure and output\ntime_format:     C like format for output of simulation time (default \"%8.4g\")\ndata_format:     C like format for output of simulation data (default \"%12.6g\")\n\n\n\n\n\n","category":"type"},{"location":"highlevel/#TensorMixedStates.Data","page":"High level interface","title":"TensorMixedStates.Data","text":"Data(name)\n\nrepresent a storage with the given name where to put measurement data\n\n\n\n\n\n","category":"type"},{"location":"highlevel/#TensorMixedStates.DataToFrame","page":"High level interface","title":"TensorMixedStates.DataToFrame","text":"DataToFrame(data)\n\nreturn a DataFrame object corresponding to the data. The DataFrames package must be imported before using this function.\n\n\n\n\n\n","category":"function"},{"location":"highlevel/#TensorMixedStates.Phases","page":"High level interface","title":"TensorMixedStates.Phases","text":"Phases = Union{CreateState, SaveState, LoadState, ToMixed, Evolve, Gates, GroundState, PartialTrace, SteadyState}\n\nA type that contains all possible phase types for SimData and runTMS. Each of the types contains at least the three following fields (like SimData).\n\nname: the name of the phase\ntime_start: the simulation time to use at the start of the phase\nfinal_measures: the measurements to make at the end of the phase see measure and output\n\n\n\n\n\n","category":"type"},{"location":"highlevel/#TensorMixedStates.CreateState","page":"High level interface","title":"TensorMixedStates.CreateState","text":"A phase type to create the simulation state\n\nFields\n\nname: the name of the phase\ntime_start: the initial simulation time\nfinal_measures: the measurements to make at the end of the phase see measure and output\ntype: the type of state to create Pure() or Mixed()\nsystem: a System object to describe the system (see System) (unused if a State object is given)\nstate: a description of the state (or a State object)\nrandomize: the link dimension for the random state to create (default 0 for no randomizing)\nseed: set the random generator seed for randomize (default nothing)\n\nExamples\n\nCreateState(type = Pure(), system = System(10, Qubit()), state = \"Up\")\nCreateState(type = Mixed(), system = System(3, Qubit()), state = [\"Up\", \"Dn\", \"Up])\nCreateState(type = Pure(), system = System(10, Qubit()), randomize = 50)\nCreateState(type = Pure(), system = System(10, Qubit()), state = \"Up\", randomize = 50)\nCreateState{Pure}(10, Qubit(), \"Up\")                                      # simple form\nCreateState{Mixed}([Qubit(), Boson(4), Fermion()], [\"Up\", \"2\", \"Occ\"])    # other simple form\n\n\n\n\n\n","category":"type"},{"location":"highlevel/#TensorMixedStates.SaveState","page":"High level interface","title":"TensorMixedStates.SaveState","text":"A phase type to save the state to disk\n\nSaveState(file = \"myfile\")\n\nnot implemented\n\n\n\n\n\n","category":"type"},{"location":"highlevel/#TensorMixedStates.LoadState","page":"High level interface","title":"TensorMixedStates.LoadState","text":"A phase type to load the state from disk\n\nLoadState(file = \"myfile\")\n\nnot implemented\n\n\n\n\n\n","category":"type"},{"location":"highlevel/#TensorMixedStates.ToMixed","page":"High level interface","title":"TensorMixedStates.ToMixed","text":"A phase type to switch to mixed representation\n\nFields\n\nname: the name of the phase\ntime_start: the simulation time to use (no much use here)\nfinal_measures: the measurements to make at the end of the phase see measure and output\nlimits : constraints on the final state\n\nExamples\n\nToMixed()\nToMixed(limits = Limits(cutoff = 1e-10, maxdim = 10))\n\n\n\n\n\n","category":"type"},{"location":"highlevel/#TensorMixedStates.Tdvp","page":"High level interface","title":"TensorMixedStates.Tdvp","text":"An algorithm type for Evolve\n\nExamples\n\nTdvp()\nTdvp(n_expand = 5)     tdvp with expansion steps every 5 steps\nTdvp(n_hermitianize = 3) tdvp, make hermitian every 3 steps\n\n\n\n\n\n","category":"type"},{"location":"highlevel/#TensorMixedStates.ApproxW","page":"High level interface","title":"TensorMixedStates.ApproxW","text":"An algorithm type for Evolve\n\nThis corresponds to time evolution with exponential approximation WI or WII combined to obtained approximation of the given order\n\nExamples\n\nApproxW(order = 2)                   order 2, WII\nApproxW(order = 4, w = 1)            order 4, WI\nApproxW(order = 4, n_hermitianize = 3) order 4, make hermitian every 3 steps\n\n\n\n\n\n","category":"type"},{"location":"highlevel/#TensorMixedStates.Evolve","page":"High level interface","title":"TensorMixedStates.Evolve","text":"A phase type for time evolution\n\nExamples\n\nEvolve(duration = 2., time_step = 0.1, algo = Tdvp(), evolver = -im*(Z(1)Z(2)+(Z(2)Z(3))), measures = [X, Y, Z])\n\nFields\n\nname: the name of the phase\ntime_start: the initial simulation time\nfinal_measures: the measurements to make at the end of the phase see measure and output\nlimits: a Limits object to set cutoff and maxdim (see Limits)\nduration: the duration of the time evolution\ntime_step: the time step\nalgo: the algorithm used (one of Tdvp() or ApproxW(...))\nevolver: the hamiltonian (evolver = -im * H) with a possible dissipator (evolver = -im * H + D)\nmeasures: the measurement to make (default [])\nmeasures_period: number of time steps between measurments (default 1)\n\n\n\n\n\n","category":"type"},{"location":"highlevel/#TensorMixedStates.Gates","page":"High level interface","title":"TensorMixedStates.Gates","text":"A phase type for applying gates\n\nFields\n\nname: the name of the phase\ntime_start: the simulation time to use at the start of the phase\nfinal_measures: the measurements to make at the end of the phase see measure and output\nlimits: constraints to enforce at each step of the computation\ngates: the gates to apply\n\nExamples\n\nGates(gates = CNOT(1, 3)*CZ(2,4), limits = Limits(cutoff=1e-10, maxdim = 20))\n\n\n\n\n\n","category":"type"},{"location":"highlevel/#TensorMixedStates.GroundState","page":"High level interface","title":"TensorMixedStates.GroundState","text":"A phase type for computing the ground state using Dmrg\n\nExamples\n\nGroundState(hamiltonian = X(1)X(2), nsweeps = 10, limits = Limits(cutoff = 1e-10, maxdim = [10, 20, 30]), tolerance = 1e-6)\n\nFields\n\nname: the name of the phase\ntime_start: the initial simulation time\nfinal_measures: the measurements to make at the end of the phase see measure and output\nhamiltonian: the Hamiltonian whose ground state is requested\nlimits: the limits on the state\nnsweeps: the maximum number of sweeps\nnoise: the noise to apply (either a number or a vector of numbers, ITensor dmrg documentation)\nmeasures: measurements to make during the computation\nmeasures_period: the interval at which the measurements are made\ntolerance: computation is stopped if the progression in the energy between sweeps is lower than this number\n\n\n\n\n\n","category":"type"},{"location":"highlevel/#TensorMixedStates.PartialTrace","page":"High level interface","title":"TensorMixedStates.PartialTrace","text":"a phase type for applying a partial trace\n\nFields\n\nname: the name of the phase\ntime_start: the initial simulation time\nfinal_measures: the measurements to make at the end of the phase see measure and output\ntrace_positions: an array of site numbers on which to trace\nkeep_positions: an array of site numbers which are not traced (all the others are)\n\nExamples\n\nPartialTrace(trace_positions = [2, 3, 6])\nPartialTrace(keep_positions = [1, 4, 5])\n\n\n\n\n\n","category":"type"},{"location":"highlevel/#TensorMixedStates.SteadyState","page":"High level interface","title":"TensorMixedStates.SteadyState","text":"a phase to compute the steady state of a Lindbladian\n\nFields\n\nname: the name of the phase\ntime_start: the initial simulation time\nfinal_measures: the measurements to make at the end of the phase see measure and output\nlindbladian: the Lindbladian whose steady state is requested (should be of the form -im * hamiltonian + dissipators)\nmpo_limits: limits on the resulting MPO\nlimits: limits on the state MPS\nnsweeps: maximum number of sweeps\nmeasures: measurements to be made during the computation\nmeasures_period: the interval at which the measurements are made\ntolerance: computation is stopped if the progression in the energy between sweeps is lower than this number\n\nExamples\n\nSteadyState(\n    lindbladian = -im * hamiltonian + dissipators,\n    limits = Limits(cutoff = 1e-20, maxdim = [10, 20, 50]),\n    nsweeps = 10,\n    tolerance = 1e-5,\n)\n\n\n\n\n\n","category":"type"},{"location":"states/#Systems-and-States","page":"Systems and States","title":"Systems and States","text":"","category":"section"},{"location":"states/#Systems","page":"Systems and States","title":"Systems","text":"","category":"section"},{"location":"states/#States","page":"Systems and States","title":"States","text":"","category":"section"},{"location":"states/#Simulations","page":"Systems and States","title":"Simulations","text":"","category":"section"},{"location":"states/#TensorMixedStates.System","page":"Systems and States","title":"TensorMixedStates.System","text":"type System\n\nrepresent a quantum system\n\nFields\n\nsites::Vector{<:AbstractSite}: sites of the system\npure_indices::Vector{Index}: Indices for pure representations\nmixed_indices::Vector{Index}: Indices for mixed representations\n\nExamples\n\nSystem(10, Qubit())\nSystem([Qubit(), SpinOne(), Qubit(), Boson(5)])\n\nIndexation\n\nsystem[i]                  gives site i\nSysIndex{Pure}(system, i)  gives pure index i\nSysIndex{Mixed}(system, i) gives mixed index i\n\n\n\n\n\n","category":"type"},{"location":"states/#Base.length-Tuple{System}","page":"Systems and States","title":"Base.length","text":"length(::System)\n\nreturn the number of sites in the system\n\n\n\n\n\n","category":"method"},{"location":"states/#NDTensors.sim-Tuple{System}","page":"Systems and States","title":"NDTensors.sim","text":"sim(::System)\n\ncreate a clone of the system: identical but with different indices\n\n\n\n\n\n","category":"method"},{"location":"states/#TensorMixedStates.:⊗-Tuple{System, System}","page":"Systems and States","title":"TensorMixedStates.:⊗","text":"::System ⊗ ::System\ntensor(::System, ::System)\n\ncreate the tensorial product of two systems\n\n\n\n\n\n","category":"method"},{"location":"states/#TensorMixedStates.Limits","page":"Systems and States","title":"TensorMixedStates.Limits","text":"A type to hold MPS limits\n\nFields\n\ncutoff: the cutoff under which singular values are neglected\nmaxdim: the maximum bond dimension\n\n\n\n\n\n","category":"type"},{"location":"states/#TensorMixedStates.State","page":"Systems and States","title":"TensorMixedStates.State","text":"struct State{R <: PM}\nState{R}(::System, states)\nState{R}(::Int, ::AbstractSite, state)\nState{R}(::Vector{<:AbstractSite}, state)\nState(::State, ::MPS)\n\nrepresent the complete state of the simulated quantum system\n\nType parameter\n\nR is Pure or Mixed and represent the type of representation used\n\nFields\n\nsystem::System: system description\nstate::MPS: system state\npreobs::PreObs: preprocessing data for computing observables\n\nExamples\n\nState{Pure}(system, \"Up\")\nState{Mixed}(system, [\"Up\", \"Dn\", \"Up\"])\nState{Mixed}(system, \"FullyMixed\")\nState{Pure}(system, [1, 0])\nState{Pure}(10, Qubit(), \"Up\")\nState{Mixed}([Qubit(), Boson(4), Fermion()], [\"Up\", \"2\", \"Occ\"])\nState(state, mps)        returns a new state with the same system but a new mps\n\nOperations\n\nstates can be added, substracted and multiplied by numbers\n\n\n\n\n\n","category":"type"},{"location":"states/#Base.length-Tuple{State}","page":"Systems and States","title":"Base.length","text":"length(::State)\n\nreturn the number of sites in the state\n\n\n\n\n\n","category":"method"},{"location":"states/#ITensorMPS.maxlinkdim-Tuple{State}","page":"Systems and States","title":"ITensorMPS.maxlinkdim","text":"maxlinkdim(::State)\n\nreturn the maximum link dimension in the state\n\n\n\n\n\n","category":"method"},{"location":"states/#TensorMixedStates.mix","page":"Systems and States","title":"TensorMixedStates.mix","text":"mix(::Index)\n\nreturn an ITensor.Index for a mixed representation corresponding to the pure representation Index given\n\n\n\n\n\nmix(::State)\n\ntransform a pure representation into a mixed representation\n\n\n\n\n\n","category":"function"},{"location":"states/#Base.truncate-Tuple{State}","page":"Systems and States","title":"Base.truncate","text":"truncate(::State; limits::Limits)\n\napply the truncations to the given state\n\n\n\n\n\n","category":"method"},{"location":"states/#TensorMixedStates.trace-Tuple{State}","page":"Systems and States","title":"TensorMixedStates.trace","text":"trace(::State)\n\nReturn the trace of the system, mostly usefull for mixed representations. This should be one.\n\n\n\n\n\n","category":"method"},{"location":"states/#TensorMixedStates.trace2","page":"Systems and States","title":"TensorMixedStates.trace2","text":"trace2(::State)\n\nReturn the trace of the square density matrix, mostly usefull for mixed representations. This is one for pure representations.\n\n\n\n\n\n","category":"function"},{"location":"states/#LinearAlgebra.norm-Tuple{State}","page":"Systems and States","title":"LinearAlgebra.norm","text":"norm(::State)\n\nReturn the norm of the state, mostly usefull for pure representations. This should be one for pure representation.\n\n\n\n\n\n","category":"method"},{"location":"states/#TensorMixedStates.hermitianize","page":"Systems and States","title":"TensorMixedStates.hermitianize","text":"hermitianize(::State)\n\nmodify the state so that it is Hermitian (only useful for mixed state)\n\n\n\n\n\n","category":"function"},{"location":"states/#TensorMixedStates.hermitianity","page":"Systems and States","title":"TensorMixedStates.hermitianity","text":"hermitianity(::State)\n\nhermitianity measure whether density matrix for mixed state is Hermitian as it should.\n\nreturn a value from 0 (anti Hermitian) to 1 (Hermitian)\n\nreturn 1 for pure state\n\n\n\n\n\n","category":"function"},{"location":"states/#TensorMixedStates.RandomState","page":"Systems and States","title":"TensorMixedStates.RandomState","text":"RandomState{Pure|Mixed}(::System, linkdims::Int)\nRandomState{Pure|Mixed}(::Int, ::AbstractSite, linkdims::Int)\nRandomState{Pure|Mixed}(::Vector{<:AbstractSite}, linkdims::Int)\nRandomState(::State, linkdims::Int)\n\nReturn a random state, with the specified link dimension. If a State is given, randomize the given state.\n\n\n\n\n\n","category":"type"},{"location":"states/#TensorMixedStates.partial_trace","page":"Systems and States","title":"TensorMixedStates.partial_trace","text":"partial_trace(::State, ::Vector{Int} [; keepers = true])\n\nreturn the state partially traced at the given positions, alternatively one can give the positions to keep by setting keepers = true\n\n\n\n\n\n","category":"function"},{"location":"states/#TensorMixedStates.Simulation","page":"Systems and States","title":"TensorMixedStates.Simulation","text":"Simulation(state[, time = 0])\nSimulation(sim, state[, time = sim.time])\n\nA type to represent simulation data and store time and file data. It is used and returned by runTMS. The first form creates a simulation object. The second updates the state in the simulation object. (see also get_sim_file)\n\nMost functions applicable to States can be applied to Simulations\n\nFields\n\nstate       : the state of the system\ntime        : the simulation time\noutput      : if not nothing an io where to redirect output\nfiles       : a dictionary holding io or dict where to write data\ndata        : a dictionary holding data collected for the Data objects\nformats     : format info for the output\n\n\n\n\n\n","category":"type"},{"location":"states/#TensorMixedStates.get_sim_file","page":"Systems and States","title":"TensorMixedStates.get_sim_file","text":"get_sim_file(::Simulation, filename)\n\nreturn the corresponding file of the given simulation \"stdout\" (or \"-\"), \"stderr\" and \"\" respectively redirect to stdout, stderr and devnull, other names are interpreted as file names.\n\nFilename finishing by \".json\" will return a Dict where to store data and this data will be output in JSON format in the file by runTMS at the end.\n\nSpecial filenames of the form Data(name) return a Dict where to store Data. Those Dict are gathered as a Dict in the data field of the Simulation\n\n\n\n\n\n","category":"function"},{"location":"#Home","page":"Home","title":"Home","text":"TensorMixedStates (TMS) is a Julia library to make simulations of closed or open quantum systems using Matrix Product States representations.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"TMS uses Matrix Product State representations for the density matrix of the system. It proposes a large set of features: manipulations of systems and states, a rich set of sites and operators easily extensible by the user, powerful algorithms: computation of ground states using DMRG, Hamiltonian and Lindbladian evolution with TDVP (and others), applications of gates (including noisy gates).\n\nBeing based on ITensor, TMS delivers high performance computations and naturally runs in parallel.\n\nThe interface is user friendly. In particular, it features a very expressive syntax for operators allowing easy definitions of operators such as observables, gates, Hamiltonians or Lindbladians. Moreover the optional high level interface allows the writing of simple simulations in a few lines of code.","category":"section"},{"location":"#References","page":"Home","title":"References","text":"To cite this software, please cite the following reference article\n\nTensorMixedStates: A Julia library for simulating pure and mixed quantum states using matrix product states","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"To use TMS, you need to have Julia installed on your system. Installing julia is usually esay and fast, see The Julia Programming Language for instructions. TMS requires at least Julia version 1.10.5 to run.\n\nTo install TMS in Julia, launch the Julia interface (by typing 'julia' on the command line) and type\n\n]add TensorMixedStates\n\nNote the \"]\" required to enter julia package management system.\n\nAfter downloading TMS, Julia will automatically compile and install it. This process usually takes a couple of minutes and does not require interactions on the user part.","category":"section"},{"location":"#Using-TMS","page":"Home","title":"Using TMS","text":"To use TMS in your code you need to write\n\nusing TensorMixedStates\n\nJulia script names are usually written with a .jl extension. Once you have written your script, you can execute it with\n\njulia my_script.jl\n\nto run it on a single processor, or\n\njulia --threads=4 my_script.jl\njulia --threads=auto my_script.jl\n\nto use multi-threading (see julia documentation for more details on multi-threading).\n\nYou can also use TMS in the interactive julia interpreter.","category":"section"},{"location":"#Bug-reports-and-features-requests","page":"Home","title":"Bug reports and features requests","text":"TMS is still in development and certainly contains bugs. If you think you have found one please report it on the Github page.\n\nFeatures requests may also be sent on the Github page.","category":"section"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"Your are currently reading it!\n\nYou can have access to inline documentation on TMS at the julia prompt simply by typing \"?\" followed by the function name or type name you are interested in. For example\n\n?runTMS\n\nFor this to work you must have first imported TMS with\n\nusing TensorMixedStates","category":"section"},{"location":"#Examples","page":"Home","title":"Examples","text":"Working examples are presented in the folder examples in the repository. ","category":"section"},{"location":"measurements/#Measurements","page":"Measurements","title":"Measurements","text":"","category":"section"},{"location":"measurements/#measure","page":"Measurements","title":"measure","text":"","category":"section"},{"location":"measurements/#Types-of-measurements","page":"Measurements","title":"Types of measurements","text":"There are five types of measurements we can ask to measure\n\nWith an indexed operator, we get the expectation of the corresponding observable\n\nmesure(state, X(1)X(2)Z(4))\n\nWith a generic operator (acting on one site only), we get the expectation of the operator on each site\n\nmeasure(state, X)\n\nWith a couple of generic operators, we get the correlation matrix of those observators\n\nmeasure(state, (X, Y))\n\nThere are a some state functions predefined:\n\nTrace              # returns the trace of the state\nTrace2                  # returns the trace of the square of the state (alternate name: Purity)\nTraceError              # returns 1 - trace, usefull for monitoring trace deviations\nRenyi2                  # returns the Renyi entropy of order 2 of the state\nSubRenyi2(sub)          # returns the Renyi entropy of order 2 of the subsystem (sub is a vector containing the indices of the sites of the subsystem)\nMutual_Info_Renyi2(sub) # returns the Renyi2 mutual information of the two subsystem (you either give one subsystem as a vector of indices or a splitting link)\nEE(l, n)                # returns entanglement entropy at site l and first n singular values\nHermitianity            # returns 1 if density matrix is really Hermitian and down to 0 for anti Hermitian density matrix\nHermitianityError       # return 1 - Hermitianity for monitoring hermitianity deviation\n\nThey are used like this\n\nmeasure(state, TraceError)\n\nNew state functions may be defined by\n\nstfunc = StateFunc(name, state->... )\n\nChecks can be performed (useful for coherence tests)\n\nmeasure(state, Check(name, obs1, obs2))      # returns 3 values ob1, obs2 and |obs2 - obs1|\nmessure(state, Check(name, obs1, obs2, tol)) # if |obs2 - obs1|>tol throw an error\nmeasure(state, Check(name, obs1, obs2), t)\n\nIn Check, obs may also be constants, vectors and function of time (like t -> sin(t)), in this case the simulation time must be fed to measure as 3rd argument.","category":"section"},{"location":"measurements/#Output","page":"Measurements","title":"Output","text":"","category":"section"},{"location":"measurements/#TensorMixedStates.measure","page":"Measurements","title":"TensorMixedStates.measure","text":"measure(state, args[, t])\nmeasure(state, measure[, t])\nmeasure(state, [measures...][, t])\n\ncompute the requested measurements on the given state and simulation time\n\nIt is more efficient to ask all required measurements in one call\n\nExamples\n\nmeasure(state, X(1))     # compute observable X(1)\nmeasure(state, X)        # compute observable X on all sites\nmeasure(state, (X, Y))   # compute correlations XY on all pairs of sites\nmeasure(state, Check(\"check\", X(1)X(2), t->sin(2t)), 0.8) # compute and check the given observable against a computed value\nmeasure(state, [X(2), Y, (X, Y)]) # several measures together\n\n\n\n\n\n","category":"function"},{"location":"measurements/#TensorMixedStates.StateFunc","page":"Measurements","title":"TensorMixedStates.StateFunc","text":"struct StateFunc\nStateFunc(name, func)\n\na data type to represent a function of State. This is used by measure. This how Trace, Purity ... are implemented.\n\nExamples\n\nTrace = StateFunc(\"Trace\", trace)\nmeasure(state, Trace)\nmeasures = \"data.dat\" => Trace\n\n\n\n\n\n","category":"type"},{"location":"measurements/#TensorMixedStates.Check","page":"Measurements","title":"TensorMixedStates.Check","text":"struct Check\nCheck(name, obs1, obs2[, tol])\n\na measurement that checks the equality between two measurements. It throws an error if the difference is larger than tol.\n\n\n\n\n\n","category":"type"},{"location":"measurements/#TensorMixedStates.Measure","page":"Measurements","title":"TensorMixedStates.Measure","text":"struct Measure\nMeasure(args...)\n\na data type to hold a set of measurements, used internally\n\n\n\n\n\n","category":"type"},{"location":"measurements/#ITensorMPS.expect","page":"Measurements","title":"ITensorMPS.expect","text":"expect(::State, obs)\n\nCompute expectation values of obs on the given state.\n\nExamples\n\nexpect(state, X(1)*Y(2) + Y(1)*Z(3))\nexpect(state, [X(1)*Y(2), X(3), Z(1)*X(2)])\n\n\n\n\n\n","category":"function"},{"location":"measurements/#TensorMixedStates.expect1","page":"Measurements","title":"TensorMixedStates.expect1","text":"expect1(::State, op)\n\nCompute the expectation values of the given operators on all sites.\n\nExamples\n\nexpect1(state, X)\nexpect1(state, [X, Y, Z])\n\n\n\n\n\n","category":"function"},{"location":"measurements/#TensorMixedStates.expect2","page":"Measurements","title":"TensorMixedStates.expect2","text":"expect2(::State, op_pairs)\n\nCompute the 2-point correlations of the given pairs of operators on all sites.\n\nExamples\n\nexpect2(state, (X, X))\nexpect2(state, [(X, Y), (X, Z), (Y, Z)])\n...\n\n\n\n\n\n","category":"function"},{"location":"measurements/#TensorMixedStates.entanglement_entropy","page":"Measurements","title":"TensorMixedStates.entanglement_entropy","text":"entanglement_entropy(::State, ::Int)\n\nReturn the entanglement entropy of the given state at the given site. Also return the associated spectrum.\n\n\n\n\n\n","category":"function"},{"location":"measurements/#TensorMixedStates.renyi2","page":"Measurements","title":"TensorMixedStates.renyi2","text":"renyi2(::State)\nrenyi2(::State, ::Vector{Int})\n\nrenyi2 returns the Renyi entropy of order 2 of the state. This is 0. for pure representations. When given an array of positions give the Renyi entropy of corresponding substate.\n\n\n\n\n\n","category":"function"},{"location":"measurements/#TensorMixedStates.mutual_info_renyi2","page":"Measurements","title":"TensorMixedStates.mutual_info_renyi2","text":"mutual_info_renyi2(state::State, cut::Int)\nmutual_info_renyi2(state::State, a::Vector{Int})\n\nreturn an approximation of the mutual information using renyi2 entropy. You define the two parts either by giving the position of the cut between the left and right parts or by giving the list of positions for one of the parts.\n\n\n\n\n\n","category":"function"},{"location":"measurements/#TensorMixedStates.Trace","page":"Measurements","title":"TensorMixedStates.Trace","text":"Trace\n\na state function to measure the trace of the system (density matrix). See also StateFunc and trace.\n\n\n\n\n\n","category":"constant"},{"location":"measurements/#TensorMixedStates.TraceError","page":"Measurements","title":"TensorMixedStates.TraceError","text":"TraceError\n\na state function to measure the deviation to trace 1 of the system (density matrix). See also StateFunc and Trace. This is good way to measure the coherence of a simulation as numerical inaccuracies tend to change the trace of the density matrix (which should stay 1)\n\n\n\n\n\n","category":"constant"},{"location":"measurements/#TensorMixedStates.Trace2","page":"Measurements","title":"TensorMixedStates.Trace2","text":"Trace2\nPurity\n\nstate functions to measure the trace of the square of the density matrix. See also StateFunc and trace2.\n\n\n\n\n\n","category":"constant"},{"location":"measurements/#TensorMixedStates.Purity","page":"Measurements","title":"TensorMixedStates.Purity","text":"Trace2\nPurity\n\nstate functions to measure the trace of the square of the density matrix. See also StateFunc and trace2.\n\n\n\n\n\n","category":"constant"},{"location":"measurements/#TensorMixedStates.Hermitianity","page":"Measurements","title":"TensorMixedStates.Hermitianity","text":"Hermitianity\n\na state function to measure the degree of hermitianity of the density matrix. Return 1 if density matrix is Hermitian, 0 for anti Hermitian, in beyween otherwise. Sea also StateFunc and hermitianity\n\n\n\n\n\n","category":"constant"},{"location":"measurements/#TensorMixedStates.HermitianityError","page":"Measurements","title":"TensorMixedStates.HermitianityError","text":"HermitianityError\n\na state function to measure the deviation of the Hermitianity from 1. See StateFunc, Hermitianity and hermitianity.\n\n\n\n\n\n","category":"constant"},{"location":"measurements/#TensorMixedStates.Renyi2","page":"Measurements","title":"TensorMixedStates.Renyi2","text":"Renyi2\n\na state function to measure the Renyi-2 entropy of the system. See also StateFunc and renyi2.\n\n\n\n\n\n","category":"constant"},{"location":"measurements/#TensorMixedStates.SubRenyi2","page":"Measurements","title":"TensorMixedStates.SubRenyi2","text":"SubRenyi2([positions...])\n\na state function to measure the Renyi-2 entropy of a subsystem describe by the positions given. See also StateFunc, Renyi2 and renyi2.\n\n\n\n\n\n","category":"function"},{"location":"measurements/#TensorMixedStates.Mutual_Info_Renyi2","page":"Measurements","title":"TensorMixedStates.Mutual_Info_Renyi2","text":"Mutual_Info_Renyi2(link)\nMutual_Info_Renyi2([positions...])\n\na state function to measure the Renyi-2 mutual information of the given subsystems. See also StateFunc and mutual_info_renyi2.\n\n\n\n\n\n","category":"function"},{"location":"measurements/#TensorMixedStates.EE","page":"Measurements","title":"TensorMixedStates.EE","text":"EE(pos)\nEE(pos, spectrum)\n\na state function to measure entanglement entropy / OSEE and associated spectrum.  See also StateFunc and entanglement_entropy.\n\n\n\n\n\n","category":"function"},{"location":"measurements/#TensorMixedStates.Linkdim","page":"Measurements","title":"TensorMixedStates.Linkdim","text":"Linkdim\n\na state function to measure the maximum bond dimension. See also StateFunc and maxlinkdim.\n\n\n\n\n\n","category":"constant"},{"location":"measurements/#TensorMixedStates.MemoryUsage","page":"Measurements","title":"TensorMixedStates.MemoryUsage","text":"MemoryUsage\n\na state function to measure the memory used by the state. See also StateFunc.\n\n\n\n\n\n","category":"constant"},{"location":"measurements/#TensorMixedStates.output","page":"Measurements","title":"TensorMixedStates.output","text":"output(::Simulation, [ filename => measure1, ... ])\n\ncompute the given measurements on a simultation and output them to the associated file or dict\n\nfilenames are interpreted by get_sim_file (see there for special values)\n\nExamples\n\noutput(sim, \"file\" => [X, X(1)Y(2), (X, Y)])\noutput(sim, [ \"file1\" => [X, Y(2)], \"file2\" => Trace])\n\n\n\n\n\n","category":"function"},{"location":"measurements/#TensorMixedStates.log_msg","page":"Measurements","title":"TensorMixedStates.log_msg","text":"log_msg(::Simulation, text)\n\nlog the given message on the \"log\" file of the simulation\n\n\n\n\n\n","category":"function"},{"location":"algorithms/#Algorithms","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"algorithms/#Ground-state-computation","page":"Algorithms","title":"Ground state computation","text":"Using DMRG, we can compute ground states for States and Simulations","category":"section"},{"location":"algorithms/#Time-evolution","page":"Algorithms","title":"Time evolution","text":"Using TDVP or ApproxW, we can do time evolution (Hamiltonian or Lindbladian)","category":"section"},{"location":"algorithms/#Gate-application","page":"Algorithms","title":"Gate application","text":"","category":"section"},{"location":"algorithms/#ITensorMPS.dmrg","page":"Algorithms","title":"ITensorMPS.dmrg","text":"dmrg(hamiltonian, ::State; options...)\ndmrg(hamiltonian, ::Simulation; options...)\n\noptimize for ground state of the given Hamiltonian starting with state / simulation using dmrg.\n\nNote that Dmrg does not work for mixed representations.\n\nOptions\n\nnsweeps: number of sweeps\nobserver!: observer (see DmrgObserver)\nlimits: constraints on the mps (cutoff and `maxdim may be vectors with different values for each sweep)\nothers identical to ITensorMPS.dmrg\n\n\n\n\n\n","category":"function"},{"location":"algorithms/#TensorMixedStates.DmrgObserver","page":"Algorithms","title":"TensorMixedStates.DmrgObserver","text":"struct DmrgObserver\nDmrgObserver(sim, measurements, period, tol)\n\nan observer for dmrg which makes and outputs measurements every period steps and stops it when energy improvements are smaller than tol\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#ITensorMPS.tdvp","page":"Algorithms","title":"ITensorMPS.tdvp","text":"tdvp(evolver, t, ::State; options...)\ntdvp(evolver, t, ::Simulation; options...)\n\ndo time evolution with tdvp algorithm on a state / sim for the given time t. Also see TdvpObserver\n\nOptions\n\nnsweeps: number sweeps to do (time step = t / nsweeps) \ncoefs: coefficients for time dependent evolver\nn_expand: do expansion steps every n_expand steps (default 0 means no expansion)\nn_hermitianize: make hermitian (for mixed states) every n_hermitianize steps (default 0 for no corrections)\nothers are identical to ITensorMPS.tdvp\n\n\n\n\n\n","category":"function"},{"location":"algorithms/#TensorMixedStates.approx_W","page":"Algorithms","title":"TensorMixedStates.approx_W","text":"approx_W(evolver, t, ::State; options...)\napprox_W(evolver, t, ::Simulation; options...)\n\ntime evolution using approximation WI or WII at a given order. Also see ApproxWObserver\n\nOptions\n\ncoefs: coefficients for time dependent evolution\nn_hermitianize: make hermitian (for mixed states) every n_hermitianize steps (default 0 for no corrections)\nnsweeps: number of steps (time step is t / nsweeps)\norder: order of approximation\nw: 1 or 2 for WI or WII\nobserver!: observer (see ApproxWObserver)\ntime_start: the simulation time at the beginning of evolution\nlimits: MPS constraints\n\n\n\n\n\n","category":"function"},{"location":"algorithms/#TensorMixedStates.TdvpObserver","page":"Algorithms","title":"TensorMixedStates.TdvpObserver","text":"struct TdvpObserver\nTdvpObserver(sim, measurements, period)\n\nan observer for tdvp which make measurements every period steps\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#TensorMixedStates.ApproxWObserver","page":"Algorithms","title":"TensorMixedStates.ApproxWObserver","text":"struct ApproxWObserver\nApproxWObserver(sim, measurements, period)\n\nan observer for approx_W which make measurements every period steps\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#ITensors.apply","page":"Algorithms","title":"ITensors.apply","text":"apply(op, ::State; limits::Limits)\napply(mps, ::State; limits::Limits)\napply(op, ::Simulation; limits::Limits)\n\nApply the given gates to the state and truncate the result according to limits. It is much more efficient to apply all the gates in a single call to apply.\n\nExamples\n\napply(CZ(1,3)*H(2)*CNOT(3,4), state)\n\n\n\n\n\n","category":"function"}]
}
