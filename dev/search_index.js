var documenterSearchIndex = {"docs":
[{"location":"sites/#Sites","page":"Sites","title":"Sites","text":"","category":"section"},{"location":"sites/#General","page":"Sites","title":"General","text":"","category":"section"},{"location":"sites/#TensorMixedStates.AbstractSite","page":"Sites","title":"TensorMixedStates.AbstractSite","text":"abstract type AbstractSite\n\nAn abstract type which is the super type of all site types\n\n\n\n\n\n","category":"type"},{"location":"sites/#NDTensors.dim-Tuple{AbstractSite}","page":"Sites","title":"NDTensors.dim","text":"dim(::AbstractSite)\n\nreturn the dimension of the given site\n\n\n\n\n\n","category":"method"},{"location":"sites/#ITensors.Index-Tuple{AbstractSite}","page":"Sites","title":"ITensors.Index","text":"Index(::AbstractSite)\n\nreturn an ITensor.Index for the given site for pure representations\n\n\n\n\n\n","category":"method"},{"location":"sites/#ITensors.SiteTypes.state-Tuple{AbstractSite, String}","page":"Sites","title":"ITensors.SiteTypes.state","text":"state(::AbstractSite, ::String)\n\nreturn the local state (as a vector or matrix) corresponding to the site and name given\n\nExamples\n\njulia> using TensorMixedStates, .Qubits, .Fermions\n\njulia> state(Qubit(), \"+\")\n2-element Vector{Float64}:\n 0.7071067811865475\n 0.7071067811865475\n\njulia> state(Fermion(), \"FullyMixed\")\n2×2 Matrix{Float64}:\n 0.5  0.0\n 0.0  0.5\n\n\n\n\n\n","category":"method"},{"location":"sites/","page":"Sites","title":"Sites","text":"The state \"FullyMixed\" represents the infinite temperature mixed state, that is a density matrix proportional to the identity matrix.","category":"page"},{"location":"sites/#TensorMixedStates.Id","page":"Sites","title":"TensorMixedStates.Id","text":"Id\n\nthe identity operator defined for all site types\n\n\n\n\n\n","category":"constant"},{"location":"sites/#TensorMixedStates.F","page":"Sites","title":"TensorMixedStates.F","text":"F\n\nthe Jordan-Wigner F operator for fermions, defined for all site types. It is the identity operator for non fermionic sites\n\n\n\n\n\n","category":"constant"},{"location":"sites/","page":"Sites","title":"Sites","text":"There are seven predefined site types Qubit, Spin, Boson, Fermion, Electron, Tj and Qboson.","category":"page"},{"location":"sites/#Qubit","page":"Sites","title":"Qubit","text":"","category":"section"},{"location":"sites/","page":"Sites","title":"Sites","text":"To use Qubit, call","category":"page"},{"location":"sites/","page":"Sites","title":"Sites","text":"using .Qubits","category":"page"},{"location":"sites/#TensorMixedStates.Qubit","page":"Sites","title":"TensorMixedStates.Qubit","text":"type Qubit\n\nA site type for representing qubit sites, that is a two level system.\n\nExample\n\nQubit()\n\nStates\n\n\"Up\", \"Z+\", \"↑\", \"0\"  : the up state\n\"Dn\", \"Z-\", \"↓\", \"1\"  : the down state\n\"+\", \"X+\"             : the + state (+1 eigenvector of X)\n\"-\", \"X-\"             : the - state (-1 eigenvector of X)\n\"i\", \"Y+\"             : the i state (+1 eigenvector of Y)\n\"-i\", \"Y-\"            : the -i state (-1 eigenvector of Y)\n\nOperators\n\nX, Y, Z          : the Pauli operators\nSp, Sm           : the S^+ and S^- operators\nSx, Sy, Sz, S2   : the S_x, S_y, S_z operators (half the Pauli operators) and S^2\nH, S, T, Swap    : the Hadamard, S, T and Swap gates\nPhase(t)         : the phase gate\ncontrolled(gate) : controlled gate\n\n\n\n\n\n","category":"type"},{"location":"sites/#TensorMixedStates.Phase","page":"Sites","title":"TensorMixedStates.Phase","text":"Phase(t)\n\nthe phase gate for qubits\n\n\n\n\n\n","category":"function"},{"location":"sites/#TensorMixedStates.controlled","page":"Sites","title":"TensorMixedStates.controlled","text":"controlled(op)\n\nthe controlled gate constructor\n\nExamples\n\nCZ = controlled(Z)\nToffoli = controlled(controlled(X))\n\n\n\n\n\n","category":"function"},{"location":"sites/#TensorMixedStates.graph_state","page":"Sites","title":"TensorMixedStates.graph_state","text":"graph_state(Pure()|Mixed(), graph::Vector{Tuple{Int, Int}}; limits)\n\ncreate a graph state corresponding to the given graph\n\nExamples\n\ngraph_state(Pure(), complete_graph(10); limits = Limits(maxdim = 10))\n\n\n\n\n\n","category":"function"},{"location":"sites/#TensorMixedStates.create_graph_state","page":"Sites","title":"TensorMixedStates.create_graph_state","text":"create_graph_state(Pure()|Mixed(), graph::Vector{Tuple{Int, Int}}; limits)\n\ncreate a phase for building a graph state to use in SimData and runTMS\n\n\n\n\n\n","category":"function"},{"location":"sites/#Spins","page":"Sites","title":"Spins","text":"","category":"section"},{"location":"sites/","page":"Sites","title":"Sites","text":"To use Spin, call","category":"page"},{"location":"sites/","page":"Sites","title":"Sites","text":"using .Spins","category":"page"},{"location":"sites/#TensorMixedStates.Spin","page":"Sites","title":"TensorMixedStates.Spin","text":"Spin(spin)\n\nA site type for representing spin sites (dim is 2 spin + 1)\n\nExample\n\nSpin(3/2)\nSpin(2)\n\nStates\n\n\"0\", \"1\", \"-1\"... for integer spins \"1/2\", \"-1/2\", \"3/2\", \"-3/2\"... for half integer spins\n\n\"X0\", \"X1/2\", \"X-1/2\", ... for eigenstate of Sx \"Y0\", \"Y1/2\", \"Y-1/2\", ... for eigenstate of Sy \"Z0\", \"Z1/2\", \"Z-1/2\", ... for eigenstate of Sz (same as \"0\", \"1/2\" ...)\n\nOperators\n\nSp, Sm           : the S^+ and S^- operators\nSx, Sy, Sz, S2   : the S_x, S_y, S_z operators and S^2\n\n\n\n\n\n","category":"type"},{"location":"sites/#Boson","page":"Sites","title":"Boson","text":"","category":"section"},{"location":"sites/","page":"Sites","title":"Sites","text":"To use Boson, call","category":"page"},{"location":"sites/","page":"Sites","title":"Sites","text":"using .Bosons","category":"page"},{"location":"sites/#TensorMixedStates.Boson","page":"Sites","title":"TensorMixedStates.Boson","text":"Boson(dim)\n\na site type to represent boson sites, it is parametred by the dimension of the Hilbert space (maximum occupancy is dim - 1)\n\nExamples\n\nBoson(4)\n\nStates\n\n\"0\", \"1\", ...\n\nOperators\n\nA : the destruction operator\nN : the number of bosons operator\n\n\n\n\n\n","category":"type"},{"location":"sites/#Fermion","page":"Sites","title":"Fermion","text":"","category":"section"},{"location":"sites/","page":"Sites","title":"Sites","text":"To use Fermion, call","category":"page"},{"location":"sites/","page":"Sites","title":"Sites","text":"using .Fermions","category":"page"},{"location":"sites/#TensorMixedStates.Fermion","page":"Sites","title":"TensorMixedStates.Fermion","text":"Fermion()\n\na site type to represent fermion sites (dim is 2)\n\nExamples\n\nFermion()\n\nStates\n\n\"0\", \"Emp\" : empty state\n\"1\", \"Occ\" : occupied state\n\nOperators\n\nC : the destruction operator\nA : the Jordan-Wigner transform of C (...C = FFFA)\nN : the number of fermions operator\n\n\n\n\n\n","category":"type"},{"location":"sites/#Electron","page":"Sites","title":"Electron","text":"","category":"section"},{"location":"sites/","page":"Sites","title":"Sites","text":"To use Electron, call","category":"page"},{"location":"sites/","page":"Sites","title":"Sites","text":"using .Electrons","category":"page"},{"location":"sites/#TensorMixedStates.Electron","page":"Sites","title":"TensorMixedStates.Electron","text":"Eletron()\n\na site type to represent electron sites (dim is 4)\n\nExamples\n\nElectron()\n\nStates\n\n\"0\", \"Emp\"   : empty state\n\"Up\", \"↑\"    : up state\n\"Dn\", \"↓\"    : down state\n\"UpDn\", \"↑↓\" : up and down state\n\nOperators\n\nCup, Cdn              : the destruction operators\nAup, Adn              : the Jordan-Wigner transforms of Cup and Cdn (...C = FFFA)\nNup, Ndn, Nupdn, Ntot : the numbers operator for up, down, up and down, and total\nSx, Sy, Sz, Sp, Sm    : spin operators\nFup, Fdn              : partial Jordan-Wigner F operators\n\n\n\n\n\n","category":"type"},{"location":"sites/#Tj","page":"Sites","title":"Tj","text":"","category":"section"},{"location":"sites/","page":"Sites","title":"Sites","text":"To use Tj, call","category":"page"},{"location":"sites/","page":"Sites","title":"Sites","text":"using .Tjs","category":"page"},{"location":"sites/#TensorMixedStates.Tj","page":"Sites","title":"TensorMixedStates.Tj","text":"Tj()\n\na site type to represent Tj sites (like Electron sites without the up and down state, dim is 3)\n\nExamples\n\nElectron()\n\nStates\n\n\"0\", \"Emp\"   : empty state\n\"Up\", \"↑\"    : up state\n\"Dn\", \"↓\"    : down state\n\nOperators\n\nCup, Cdn              : the destruction operators\nAup, Adn              : the Jordan-Wigner transforms of Cup and Cdn (...C = FFFA)\nNup, Ndn, Ntot        : the numbers operator for up, down and total\nSx, Sy, Sz, Sp, Sm    : spin operators\nFup, Fdn              : partial Jordan-Wigner F operators\n\n\n\n\n\n","category":"type"},{"location":"sites/#Qboson","page":"Sites","title":"Qboson","text":"","category":"section"},{"location":"sites/","page":"Sites","title":"Sites","text":"To use Qboson, call","category":"page"},{"location":"sites/","page":"Sites","title":"Sites","text":"using .Qbosons","category":"page"},{"location":"sites/#TensorMixedStates.Qboson","page":"Sites","title":"TensorMixedStates.Qboson","text":"Qboson(q, dim)\n\na site type to represent q-boson sites, it is parametred by q and the dimension of the Hilbert space (maximum occupancy is dim - 1).\n\nanrangle = sqrt1-q^n n-1rangle and a^dagger nrangle = sqrt1 - q^n+1 n+1rangle\n\nExamples\n\nQboson(0.1, 4)\n\nStates\n\n\"0\", \"1\", ...\n\nOperators\n\nA : the destruction operator\nN : the number of q-bosons operator\n\n\n\n\n\n","category":"type"},{"location":"sites/#Defining-new-site-types","page":"Sites","title":"Defining new site types","text":"","category":"section"},{"location":"sites/","page":"Sites","title":"Sites","text":"To define a new site type, you need to define a new subtype of AbstractSite and define dim and possibly generic_state on it (to overload do not forget to use the full name e.g. TensorMixedStates.dim). Then define its specific states and operators using @def_states and @def_operators. Don't forget to define the F operator for fermionic sites.","category":"page"},{"location":"sites/#TensorMixedStates.generic_state","page":"Sites","title":"TensorMixedStates.generic_state","text":"generic_state(::AbstractSite, ::String)\n\nDo not call directly. It returns a local state corresponding to the string, this is tried first before trying specifically defined states.\n\nThe default implementation returns the first state for \"0\", the second for \"1\" and so on.\n\nThis should be overloaded if necessary when defining new site types. It may return an error when not needed.\n\n\n\n\n\n","category":"function"},{"location":"sites/#TensorMixedStates.@def_states","page":"Sites","title":"TensorMixedStates.@def_states","text":"@def_states(site, symbols)\n\ndefine the given states for the given site\n\nExample\n\n@def_states(Fermion(),\n[\n    [\"Emp\", \"0\"] => [1., 0.],\n    \"Occ\" => [0., 1.],\n])\n\n\n\n\n\n","category":"macro"},{"location":"sites/#TensorMixedStates.@def_operators","page":"Sites","title":"TensorMixedStates.@def_operators","text":"@def_operators(site, symbols, fermionic=false)\n\ndefine the given operator for the given site\n\nExamples\n\n@def_operators(Fermion(),\n[\n    C = [0. 1. ; 0. 0.],\n],\ntrue)\n\n@def_operators(Fermion(),\n[\n    F = [1. 0. ; 0. -1.],\n    A = C,\n    N = dag(C)*C\n])\n\n\n\n\n\n","category":"macro"},{"location":"operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"operators/#Usage","page":"Operators","title":"Usage","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"There are two kinds of operators: generic (like X) and indexed (like X(3)). Indexed operators are applied to specific site numbers.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Operators can be used to defined Hamiltonians, for example\nhamiltonian = - j * sum(X(i)X(i+1) + Y(i)Y(i+1) for i in 1:n-1) - h * sum(Z(i) for i in 1:n)","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"or Lindbladian dissipators like","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"dissipators = sum(Dissipator(Sp)(i) for i in 1:n)","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"to build Lindbladian","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"lindbladian = -im * hamiltonian + dissipators","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Note the factor -im for the Hamiltonian.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Operators can be used to define quantum gates like\ngates = H(1)Swap(1, 2)H(1)","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Noisy gates can be defined using the Gate constructor, for example","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"noisygate = 0.7Gate(Id) + 0.1Gate(X) + 0.1Gate(Y) + 0.1Gate(Z)","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Operators can be used to define observables\nobs = X(1)X(2)Z(3)","category":"page"},{"location":"operators/#Reference","page":"Operators","title":"Reference","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Complex operators can be build from a rich set of functions, for example","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Rxy(t) = exp(-im * t * (X⊗X + Y⊗Y) / 4)","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Operators can be added and multiplied using usual operators (+, -, *, /, ^).","category":"page"},{"location":"operators/#TensorMixedStates.Pure","page":"Operators","title":"TensorMixedStates.Pure","text":"type Pure\nPure()\n\ncorrespond to pure quantum representation\n\n\n\n\n\n","category":"type"},{"location":"operators/#TensorMixedStates.Mixed","page":"Operators","title":"TensorMixedStates.Mixed","text":"type Mixed\nMixed()\n\ncorrespond to mixed quantum representation\n\n\n\n\n\n","category":"type"},{"location":"operators/#TensorMixedStates.ExprOp","page":"Operators","title":"TensorMixedStates.ExprOp","text":"abstract type ExprOp{T, N}\n\nthe abstract type of operators, T is Pure or Mixed and N is an Int for generic operators (the number of sites on which the operator may apply) and IndexOp for indexed operators\n\nSimpleOp = ExprOp{Pure, 1}\nExprIndexed{T} = ExprOp{T, IndexOp}\n\n\n\n\n\n","category":"type"},{"location":"operators/#TensorMixedStates.Operator","page":"Operators","title":"TensorMixedStates.Operator","text":"type Operator{T, N} <: ExprOp{T, N}\n\nthe type of base operators (like X, Swap, C ...), T is Pure or Mixed and N is an Int.\n\nExample\n\nOperator(\"X\")                      a base operator whose value is predefined by the sites\nOperator(\"Z\", [1 0 ; 0 -1])\nOperator{Pure, 2}(\"Swap\", [ 1 0 0 0 ; 0 0 1 0 ; 0 1 0 0 ; 0 0 0 1])\nOperator(\"CX\", controlled(X))\nOperator(\"Sx\", (Sp + Sm) / 2)\nOperator(\"C\", [0 1 ; 0 0], true)   a fermionic operator\n\n\n\n\n\n","category":"type"},{"location":"operators/#TensorMixedStates.Indexed","page":"Operators","title":"TensorMixedStates.Indexed","text":"type Indexed{T, N} <: ExprIndexed{T}\n\nrepresent a base indexed operator (like X(1) or Swap(2, 4))\n\n\n\n\n\n","category":"type"},{"location":"operators/#TensorMixedStates.:⊗","page":"Operators","title":"TensorMixedStates.:⊗","text":"op1 ⊗ op2\n\ntensor product for generic operators, alternative syntax: tensor(op1, op2)\n\nExamples\n\ncontrolled(op) = Proj(\"Up\") ⊗ Id + Proj(\"Dn\") ⊗ op\nRxy(t) = exp(im * t * (X ⊗ X + Y ⊗ Y) / 4)\n\n\n\n\n\n::System ⊗ ::System\ntensor(::System, ::System)\n\ncreate the tensorial product of two systems\n\n\n\n\n\n","category":"function"},{"location":"operators/#TensorMixedStates.Proj","page":"Operators","title":"TensorMixedStates.Proj","text":"Proj(state)\n\nan operator to project on the given state\n\nExamples\n\nProj(\"Up\")\nProj([1, 0])\n\n\n\n\n\n","category":"type"},{"location":"operators/#TensorMixedStates.Dissipator","page":"Operators","title":"TensorMixedStates.Dissipator","text":"Dissipator(op)\n\na Lindbladian dissipator based on op to be used in evolver for time evolution\n\n\n\n\n\n","category":"type"},{"location":"operators/#TensorMixedStates.Gate","page":"Operators","title":"TensorMixedStates.Gate","text":"Gate(op)\n\na generic operator acting as a gate on states in mixed representation. Usefull for building noisy gates\n\nExamples\n\nG = 0.9 * Gate(Id) + 0.1 Gate(X)\n\n\n\n\n\n","category":"type"},{"location":"operators/#ITensors.dag-Tuple{ExprOp}","page":"Operators","title":"ITensors.dag","text":"dag(::ExprOp)\n\nadjoint for generic operators\n\n\n\n\n\n","category":"method"},{"location":"operators/#TensorMixedStates.fermionic","page":"Operators","title":"TensorMixedStates.fermionic","text":"fermionic(a::ExprOp)\n\nreturn whether an operator is fermionic or not\n\n\n\n\n\n","category":"function"},{"location":"operators/#NDTensors.matrix","page":"Operators","title":"NDTensors.matrix","text":"matrix(a::ExprOp, site::AbstractSite...)\n\nreturn the matrix of a generic operator for the given sites. If sites are all identical, you may give only one\n\nExamples\n\nmatrix(X, Qubit())\nmatrix(Swap, Qubit())\nmatrix(X⊗A, Qubit(), Boson(2))\n\n\n\n\n\n","category":"function"},{"location":"operators/#TensorMixedStates.tensor","page":"Operators","title":"TensorMixedStates.tensor","text":"tensor(a::ExprOp, site::AbstractSite...)\n\nreturn the ITensor of a generic operator for the given sites. If sites are all identical, you may give only one\n\nExamples\n\ntensor(X, Qubit())\ntensor(Swap, Qubit())\ntensor(X⊗A, Qubit(), Boson(2))\n\n\n\n\n\ntensor(::System, ::Indexed)\n\nreturns a tensor representing the given base indexed operator acting on this system\n\n\n\n\n\n","category":"function"},{"location":"operators/#TensorMixedStates.simplify","page":"Operators","title":"TensorMixedStates.simplify","text":"simplify(op)\n\nsimplify indexed operator\n\n\n\n\n\n","category":"function"},{"location":"operators/#TensorMixedStates.insertFfactors","page":"Operators","title":"TensorMixedStates.insertFfactors","text":"insertFfactors\n\ninsert the Jordan-Wigner F operators where needed\n\n\n\n\n\n","category":"function"},{"location":"operators/#TensorMixedStates.process","page":"Operators","title":"TensorMixedStates.process","text":"process(op)\n\nsimplify indexed operator and insert Jordan-Wigner F factors where needed\n\n\n\n\n\n","category":"function"},{"location":"manual/#Manual","page":"Manual","title":"Manual","text":"","category":"section"},{"location":"manual/#Import","page":"Manual","title":"Import","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"To use TMS, you must first import it with","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using TensorMixedStates","category":"page"},{"location":"manual/#Sites-and-Systems","page":"Manual","title":"Sites and Systems","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"The first step in using TMS is the definition of your quantum system. In TMS, a system is composed of a finite number of sites numbered from 1 (1, 2, ..., N). These sites may be all identical or not.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"There are seven different predefined types of site: Qubit, Fermion, Boson, Spin, Electron, Tj and Qboson.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"To use each of these sites and the corresponding predefined operators you need first to import the corresponding module. For example to use qubits, you need to write","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using .Qubits","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Note the \".\" before the name and the \"s\" at the end.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"To define a site just call the corresponding creator for example","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"s = Qubit()","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Some site creators need arguments: Boson (for the maximum occupancy) and Spin, for example","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"s = Boson(4)\ns = Spin(3/2)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"You can now define a quantum system by declaring the sites it contains:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"system1 = System(10, Qubit())","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"gives you a system with 10 qubits. Systems may have different types of site, in this case you must feed System with an array of sites","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"system2 = System([Qubit(), Boson(4), Fermion()])","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"gives you a three site system.","category":"page"},{"location":"manual/#States","page":"Manual","title":"States","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"States may be in pure or mixed representation, these two possibilities are represented in TMS, by Pure() or Mixed() (note the parenthesis).","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"To create a state, we call the State creator","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"state1 = State(Pure(), system1, \"Up\")","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"returns a pure up state in a 10 qubit system. Predefined local states are designated by there name. Here \"Up\" is a predefined state of site Qubit.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"All sites need not be all in the same local states, in which case we give State an array of local states","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"state2 = State(Mixed(), system2, [\"+\", \"2\", \"Occ\"])","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Here we chose a mixed representation.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"States may be added or multiplied by a number (they need to be based on the same system). For example","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"ghz = (State(Pure(), system1, \"Up\") + State(Pure(), system1, \"Dn\")) / 2","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"We can transform a pure representation into a mixed representation by","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"mixedstate = mix(purestate)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For mixed states there is a local mixed state \"FullyMixed\" which correspond to a density matrix proportional to the identity matrix.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"If you need a local state which is not predefined, it is possible to pass its vector (or matrix for mixed states) directly, For example, we could also define state1 by","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"state1 = State(Pure(), system1, [1., 0.])","category":"page"},{"location":"manual/#Limits","page":"Manual","title":"Limits","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"TMS uses Matrix Product State to internally represent quantum states. It is important to control the parameters of this approximation, in particular the maximum bond dimension and the cutoff on singular values. To achieve this, many functions accept a Limits object as keyword argument containing those parameters. It is build thus","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"lim = Limits(cutoff = 1e-10, maxdim = 50)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"each (or both) of the arguments may be omitted in which case it corresponds to an absence of constraint for this parameter. In particular, Limits() represents no constraint.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"To apply the constraints on a state, one uses","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"newstate = truncate(oldstate; limits = lim)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Many functions accept such an argument. For example, when adding states instead of","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"state = (state1 + state2) / 2","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"One can write","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"state = +(state1, state2; limits = lim) / 2","category":"page"},{"location":"manual/#Operators","page":"Manual","title":"Operators","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"In TMS, there are two kinds of operators: generic operators and indexed operators. For example,","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"X","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"represents the sigma_x Pauli operator for qubits. This is a generic operator, it is not applied to a specific site.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"X(3)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"represents the sigma_x Pauli operator applied to the system site number 3. This is an indexed operator.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Note that all predefined operator names start with a capital letter, so it is better to keep your own identifiers lowercase to prevent name collisions.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The operator system is very rich and flexible. For example, if you want to use this Hamiltonian","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"H = sum_i=1^n-1 sigma_x(i) sigma_x(i+1)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"you will simply write","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"h = sum(X(i)X(i+1) for i in 1:n-1)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Many operations are defined on generic operators:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"addition, multiplication and power by a number\ntensor product: X⊗X is a two site operator (one can also write tensor(X, X))\ndag represents the adjoint operator, for example C is the c operator for fermions and dag(C) is c^dagger.\nDissipator represents a Lindblad dissipator, for example Dissipator(Sp) is the jump operator that may flip a qubit toward up (Sp is the S^+ operator)\nGate represents an operator to be applied as a gate on a mixed state. It is useful to define noisy gate operators, for example 0.9 Gate(Id) + 0.1 Gate(X) is a noisy gate operator that will apply an sigma_x gate 10 percent of the time.\nProj represents an operator that projects on the given state, for example Proj(\"Up\") projects qubits on the up state.\nthe functions exp and sqrt: for example sqrt(Swap)\ncontrolled for qubits makes controlled gates: CX = controlled(X)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For example one can define the Rxy 2-site operator by","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Rxy(t) = exp(-im * t * (X⊗X + Y⊗Y) / 4)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"If this is not enough to define your favorite operator you can create new ones by specifying their matrix","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"myop = Operator(\"MyOp\", [1 1 ; 1 -1] / √2)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For multiple site or mixed operators you must specify the type","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Swap = Operator{Pure, 2}(\"Swap\", [1 0 0 0 ; 0 0 1 0 ; 0 1 0 0 ; 0 0 0 1])","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Finally from generic operators, we define indexed operators by simply applying them to the corresponding sites","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Rxy(0.2)(2, 5)\nmyop(3)\nSwap(4, 7)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"In the case of Hamiltonian or Lindbladian evolution the Hamiltonian part is to be multiplied by -im:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"evolver = -im * hamiltonian + dissipators","category":"page"},{"location":"manual/#Algorithms","page":"Manual","title":"Algorithms","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"We can now work with states and operators.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"We can apply gates with apply","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"newstate = apply(gates, oldstate; limits)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"the gates argument is an indexed operator representing the gates to apply","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"the keyword argument limits fixes the constraints to apply","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"We can compute ground states with dmrg","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"groundstate, energy = dmrg(hamiltonian, startstate; options...)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"the options are limits to set constraints and nsweeps to fix the number of sweeps among others.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"We can do time evolution with tdvp and approx_W","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"newstate = tdvp(evolver, time, oldstate; options...)\nnewstate = approx_W(evolver, time, oldstate; options...)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"the options are limits for the constraints, nsweeps for the number of step to do and for approx_W, order and w for the parameters of the algorithm (order = 4, w = 2 are usually good)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For more details, see the reference or the inline help.","category":"page"},{"location":"manual/#Measurements","page":"Manual","title":"Measurements","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Once we have created a state, we may want to measure it.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"result = measure(state, X(1)X(3))","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"will give langle psi  sigma_x^1 sigma_x^3  psi rangle","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"result = measure(state, X)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"will give the array of the langle psi  sigma_x^i  psi rangle","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"result = measure(state, (X, Y))","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"will give the matrix of the langle psi  sigma_x^i sigma_y^j  psi rangle","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"We can also measure other properties with Trace, TraceError, Trace2, Purity, Hermitianity, HermitianityError, EE, Linkdim and MemoryUsage.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"We can also ask for several measurements at the same time","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"results = measure(state, [X, X(2)Z(3), (X, Y), Trace, MemoryUsage])","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For more details see the reference or the inline help.","category":"page"},{"location":"manual/#High-Level-Interface","page":"Manual","title":"High Level Interface","text":"","category":"section"},{"location":"manual/#Framework","page":"Manual","title":"Framework","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"Most simulations follow the same pattern: start from some simple state, make some evolution and make measurements during or after the evolution and save the results to file. For these simple cases, TMS proposes a simpler interface.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"A simple simulation follows a single state through a certain number of phases which act in a simple way on the state and make measurements during and/or after the evolution and save the results to file.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The following phases are available:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"CreateState : create a simple state\nDMRG : compute the ground state (requires a pure state)\nToMixed : go from pure representation to mixed representation\nEvolve : do Hamiltonian or Lindbladian evolution\nGates : apply some gates\nPartialTrace : trace the system over some sites (requires a mixed state)\nSteadyState : compute the steady state of a Lindblad equation (requires a mixed state)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"with these phases we define a SimData object that describes the simulation and finally, we call","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"runTMS(simdata)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"which executes the simulation.","category":"page"},{"location":"manual/#Example","page":"Manual","title":"Example","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"As an example, here is the complete code for such a simple simulation:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"using TensorMixedStates, .Fermions\n\nhamiltonian(n) = -sum(dag(C)(i)C(i+1)+dag(C)(i+1)C(i) for i in 1:n-1)\ndissipators(n, gamma) = sum(Dissipator(sqrt(4gamma) * N)(i) for i in 1:n)\n\nsim_data(n, gamma, step) = SimData(\n    name = \"Fermion tight-binding chain with dephasing noise\",\n    phases = [\n        CreateState(\n            type = Mixed(),\n            sytem = System(n, Fermion()),\n            state = [ iseven(i) ? \"Occ\" : \"Emp\" for i in 1:n ]),\n        Evolve(\n            duration = 4,\n            time_step = step,\n            algo = Tdvp(),\n            evolver = -im*hamiltonian(n) + dissipators(n, gamma),\n            limits = Limits(cutoff = 1e-30, maxdim = 100),\n            measures = [\n                \"density.dat\" => N,\n                \"OSEE.dat\" => EE(div(n, 2))\n            ]\n        )\n    ]\n)\n\nrunTMS(sim_data(40, 1., 0.05))","category":"page"},{"location":"manual/#Output","page":"Manual","title":"Output","text":"","category":"section"},{"location":"manual/","page":"Manual","title":"Manual","text":"runTMS creates a directory named after the SimData object name field and puts the output files there. In particular, it produces a log file showing the progression of the computation, a prog.jl file containing a copy of the script, a description file containing the content of the SimData description field, a stamp file containing version and date info, a running empty file is present during the computation, in case of error an empty error file is created.","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Three keyword arguments may be given restart (default true) erases the directory before starting, clean (default false) erases the directory and does not run the simulation, output (default nothing) if set, does not create the directory nor any output files an redirect all output to the given io channel (useful values are stdout and devnull). ","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"Measurements are specified in the measures or final_measures fields. They take the form of a pair","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"measures = destination => measurements","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"or a list of pairs. The possible measurements are described in the measurements section of this manual. There are three types of destinations:","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"filenames: writes the specified measurements to the given file as they are made. Special filenames are \"stdout\" (or \"-\"), \"stderr\", \"\" (for devnull)\n\"file.dat\" => X\njson filenames: filenames ending by \".json\" are treated differently: data is accumulated during the simulation and written at the end in the JSON format.\n\"file.json\" => [Purity, X(2)Z(3), (X, Y)]\nData object: data is accumulated during the simulation and stored in the data field of the Simulation object returned by runTMS. This is useful for analyzing the data inside the program.\nData(\"mydata\") => [TraceError, X(1), Y]","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"The DataToFrame function can used on the result to get a DataFrame object (the user must import the DataFrames package himself before using this function)","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"sim = runTMS(simdata)\ndf = DataToFrame(sim.data[\"mydata\"])","category":"page"},{"location":"manual/","page":"Manual","title":"Manual","text":"For more information, see the reference or inline help for each phase, SimData and runTMS.","category":"page"},{"location":"others/#Others","page":"Others","title":"Others","text":"","category":"section"},{"location":"others/#Graphs","page":"Others","title":"Graphs","text":"","category":"section"},{"location":"others/","page":"Others","title":"Others","text":"graphs are useful to describe interactions or gates to apply ","category":"page"},{"location":"others/#TensorMixedStates.line_graph","page":"Others","title":"TensorMixedStates.line_graph","text":"line_graph(n)\n\nreturn the graph 1-2, 2-3, ..., (n-1)-n\n\n\n\n\n\n","category":"function"},{"location":"others/#TensorMixedStates.circle_graph","page":"Others","title":"TensorMixedStates.circle_graph","text":"circle_graph(n)\n\nreturn the graph 1-2, 2-3, ..., (n-1)-n, n-1\n\n\n\n\n\n","category":"function"},{"location":"others/#TensorMixedStates.complete_graph","page":"Others","title":"TensorMixedStates.complete_graph","text":"complete_graph(n)\n\nreturn the complete graph with n vertices 1-2, 1-3, 2-3, 1-4, 2-4, 3-4 ...\n\n\n\n\n\n","category":"function"},{"location":"others/#TensorMixedStates.graph_base_size","page":"Others","title":"TensorMixedStates.graph_base_size","text":"graph_base_size(::Vector{Tuple{Int, Int}})\n\nreturn the maximum vertex number in a graph\n\n\n\n\n\n","category":"function"},{"location":"others/#MPO","page":"Others","title":"MPO","text":"","category":"section"},{"location":"others/","page":"Others","title":"Others","text":"Matrix Product Operators (MPO) are used under the hood by TMS to operate on MPS (inner state representation). Except for apply and measure all operators are converted to MPO internally.","category":"page"},{"location":"others/#TensorMixedStates.PreMPO","page":"Others","title":"TensorMixedStates.PreMPO","text":"PreMPO(::State, op)\n\npreprocess an operator (or vector of operators). The result can be passed wherever an operator that must be turned into an MPO is expected\n\n\n\n\n\n","category":"type"},{"location":"others/#TensorMixedStates.make_mpo","page":"Others","title":"TensorMixedStates.make_mpo","text":"make_mpo(::PreMPO[, coefs])\nmake_mpo(::State, operator)\n\nbuild an mpo representing an operator\n\n\n\n\n\n","category":"function"},{"location":"others/#TensorMixedStates.make_approx_W1","page":"Others","title":"TensorMixedStates.make_approx_W1","text":"make_approx_W1(::PreMPO, tau[, coefs])\nmake_approx_W1(::State, operator, tau)\n\nbuild MPO representing approximation WI of a given operator and time step\n\n\n\n\n\n","category":"function"},{"location":"others/#TensorMixedStates.make_approx_W2","page":"Others","title":"TensorMixedStates.make_approx_W2","text":"make_approx_W2(::PreMPO, tau[, coefs])\nmake_approx_W2(::State, operator, tau)\n\nbuild MPO representing approximation WII of a given operator and time step\n\n\n\n\n\n","category":"function"},{"location":"others/#Time-dependent-operators","page":"Others","title":"Time dependent operators","text":"","category":"section"},{"location":"others/","page":"Others","title":"Others","text":"For time evolution, it may be useful to have time dependent operators. In TMS, a time dependent operator is described in the following way: a vector of indexed operators and a vector of time functions. For example, to describe","category":"page"},{"location":"others/","page":"Others","title":"Others","text":"    h(t) = - e^-t sum_i=1^n-1 sigma_x^i sigma_x^i+1 - sin(t) sum_i=1^n sigma_z^i  ","category":"page"},{"location":"others/","page":"Others","title":"Others","text":"we use","category":"page"},{"location":"others/","page":"Others","title":"Others","text":"hs = -im * [ -sum(X(i)X(i+1) for i in 1:n-1), -sum(Z(i) for i in 1:n)]","category":"page"},{"location":"others/","page":"Others","title":"Others","text":"and","category":"page"},{"location":"others/","page":"Others","title":"Others","text":"coefs = [ t -> exp(-t), t -> sin(t) ]","category":"page"},{"location":"others/","page":"Others","title":"Others","text":"h is passed as usual to tdvp or approx_W and coefs is passed as a keyword argument called coefs. When using Simulation the simulation time is used for t, for State the initial simulation time is passed as a keyword argument called time_start (which default to 0)","category":"page"},{"location":"others/","page":"Others","title":"Others","text":"tdvp(hs, duration, initial_state; coefs, time_start)","category":"page"},{"location":"others/","page":"Others","title":"Others","text":"With the high level interface, one can use time dependent evolver for the Evolve phase with the following syntax","category":"page"},{"location":"others/","page":"Others","title":"Others","text":"evolver = hs => coefs","category":"page"},{"location":"highlevel/#High-level-interface","page":"High level interface","title":"High level interface","text":"","category":"section"},{"location":"highlevel/#TensorMixedStates.runTMS","page":"High level interface","title":"TensorMixedStates.runTMS","text":"runTMS(::SimData)\nrunTMS(::SimData; clean = true)\nrunTMS(::SimData; restart = true)\nrunTMS(::SimData; output = myoutput)\n\nrun the given simulation (see SimData for details), write the output to file and return a Simulation object containing the result. clean (default false) remove the simulation directory and exit, restart (default false) remove the simulation directory and run the simulation, output redirect all output to the given IO channel (no output directory created), usefull values are stdout or devnull (to suppress all output).\n\n\n\n\n\n","category":"function"},{"location":"highlevel/#TensorMixedStates.SimData","page":"High level interface","title":"TensorMixedStates.SimData","text":"SimData(name = \"my_simulation\", phases::Vector{Phases} = [phase1, phase2...])\n\nA type for describing a simulation to use with runTMS\n\nFields\n\nname:            the name of the simulation used as the name of the directory to store the results\nphases:          the list of phases of the simulation (see Phases for a list of possible values)\ndescritpion:     text put in the description file of the simulation (default \"\")\ntime_start:      initial simulation time (default 0.)\nfinal_measures:  measures to make at the end of simulation (default []) see measure and output\ntime_format:     C like format for output of simulation time (default \"%8.4g\")\ndata_format:     C like format for output of simulation data (default \"%12.6g\")\n\n\n\n\n\n","category":"type"},{"location":"highlevel/#TensorMixedStates.Data","page":"High level interface","title":"TensorMixedStates.Data","text":"Data(name)\n\nrepresent a storage with the given name where to put measurement data\n\n\n\n\n\n","category":"type"},{"location":"highlevel/#TensorMixedStates.DataToFrame","page":"High level interface","title":"TensorMixedStates.DataToFrame","text":"DataToFrame(data)\n\nreturn a DataFrame object corresponding to the data. The DataFrames package must be imported before using this function.\n\n\n\n\n\n","category":"function"},{"location":"highlevel/#TensorMixedStates.Phases","page":"High level interface","title":"TensorMixedStates.Phases","text":"Phases = Union{CreateState, SaveState, LoadState, ToMixed, Evolve, Gates, Dmrg, PartialTrace, SteadyState}\n\nA type that contains all possible phase types for SimData and runTMS. Each of the types contains at least the three following fields (like SimData).\n\nname: the name of the phase\ntime_start: the simulation time to use at the start of the phase\nfinal_measures: the measurements to make at the end of the phase see measure and output\n\n\n\n\n\n","category":"type"},{"location":"highlevel/#TensorMixedStates.CreateState","page":"High level interface","title":"TensorMixedStates.CreateState","text":"A phase type to create the simulation state\n\nFields\n\nname: the name of the phase\ntime_start: the initial simulation time\nfinal_measures: the measurements to make at the end of the phase see measure and output\ntype: the type of state to create Pure() or Mixed()\nsystem: a System object to describe the system (see System) (unused if a State object is given)\nstate: a description of the state (or a State object)\nrandomize: the link dimension for the random state to create (default 0 for no randomizing)\n\nExamples\n\nCreateState(type = Pure(), system = System(10, Qubit()), state = \"Up\")\nCreateState(type = Mixed(), system = System(3, Qubit()), state = [\"Up\", \"Dn\", \"Up])\nCreateState(type = Pure(), system = System(10, Qubit()), randomize = 50)\nCreateState(type = Pure(), system = System(10, Qubit()), state = \"Up\", randomize = 50)\nCreateState(Pure(), 10, Qubit(), \"Up\")                                      # simple form\nCreateState(Mixed(), [Qubit(), Boson(4), Fermion()], [\"Up\", \"2\", \"Occ\"])    # other simple form\n\n\n\n\n\n","category":"type"},{"location":"highlevel/#TensorMixedStates.SaveState","page":"High level interface","title":"TensorMixedStates.SaveState","text":"A phase type to save the state to disk\n\nSaveState(file = \"myfile\")\n\nnot implemented\n\n\n\n\n\n","category":"type"},{"location":"highlevel/#TensorMixedStates.LoadState","page":"High level interface","title":"TensorMixedStates.LoadState","text":"A phase type to load the state from disk\n\nLoadState(file = \"myfile\")\n\nnot implemented\n\n\n\n\n\n","category":"type"},{"location":"highlevel/#TensorMixedStates.ToMixed","page":"High level interface","title":"TensorMixedStates.ToMixed","text":"A phase type to switch to mixed representation\n\nFields\n\nname: the name of the phase\ntime_start: the simulation time to use (no much use here)\nfinal_measures: the measurements to make at the end of the phase see measure and output\nlimits : constraints on the final state\n\nExamples\n\nToMixed()\nToMixed(limits = Limits(cutoff = 1e-10, maxdim = 10))\n\n\n\n\n\n","category":"type"},{"location":"highlevel/#TensorMixedStates.Tdvp","page":"High level interface","title":"TensorMixedStates.Tdvp","text":"An algorithm type for Evolve\n\nExamples\n\nTdvp()\nTdvp(n_expand = 5)     tdvp with expansion steps every 5 steps\nTdvp(n_symmetrize = 3) tdvp, make hermitian every 3 steps\n\n\n\n\n\n","category":"type"},{"location":"highlevel/#TensorMixedStates.ApproxW","page":"High level interface","title":"TensorMixedStates.ApproxW","text":"An algorithm type for Evolve\n\nThis corresponds to time evolution with exponential approximation WI or WII combined to obtained approximation of the given order\n\nExamples\n\nApproxW(order = 2)                   order 2, WII\nApproxW(order = 4, w = 1)            order 4, WI\nApproxW(order = 4, n_symmetrize = 3) order 4, make hermitian every 3 steps\n\n\n\n\n\n","category":"type"},{"location":"highlevel/#TensorMixedStates.Evolve","page":"High level interface","title":"TensorMixedStates.Evolve","text":"A phase type for time evolution\n\nExamples\n\nEvolve(duration = 2., time_step = 0.1, algo = Tdvp(), evolver = -im*(Z(1)Z(2)+(Z(2)Z(3))), measures = [X, Y, Z])\n\nFields\n\nlimits: a Limits object to set cutoff and maxdim (see Limits)\nduration: the duration of the time evolution\ntime_step: the time step\nalgo: the algorithm used (one of Tdvp() or ApproxW(...))\nevolver: the hamiltonian (evolver = -im * H) with a possible dissipator (evolver = -im * H + D)\nmeasures: the measurement to make (default [])\nmeasures_period: number of time steps between measurments (default 1)\n\n\n\n\n\n","category":"type"},{"location":"highlevel/#TensorMixedStates.Gates","page":"High level interface","title":"TensorMixedStates.Gates","text":"A phase type for applying gates\n\nname: the name of the phase\ntime_start: the simulation time to use at the start of the phase\nfinal_measures: the measurements to make at the end of the phase see measure and output\nlimits: constraints to enforce at each step of the computation\ngates: the gates to apply\n\nExamples\n\nGates(gates = CNOT(1, 3)*CZ(2,4), limits = Limits(cutoff=1e-10, maxdim = 20))\n\n\n\n\n\n","category":"type"},{"location":"highlevel/#TensorMixedStates.Dmrg","page":"High level interface","title":"TensorMixedStates.Dmrg","text":"A phase type for optimizing with Dmrg\n\nExamples\n\nDmrg(hamiltonian = X(1)X(2), nsweeps = 10, limits = Limits(cutoff = 1e-10, maxdim = [10, 20, 30]), tolerance = 1e-6)\n\n\n\n\n\n","category":"type"},{"location":"highlevel/#TensorMixedStates.PartialTrace","page":"High level interface","title":"TensorMixedStates.PartialTrace","text":"a phase type for applying a partial trace\n\nExamples\n\nPartialTrace(trace_positions = [2, 3, 6])\nPartialTrace(keep_positions = [1, 4, 5])\n\n\n\n\n\n","category":"type"},{"location":"highlevel/#TensorMixedStates.SteadyState","page":"High level interface","title":"TensorMixedStates.SteadyState","text":"a phase to compute the steady state of a Lindbladian\n\nExamples\n\nSteadyState(\n    lindbladian = -im * hamiltonian + dissipators,\n    limits = Limits(cutoff = 1e-20, maxdim = [10, 20, 50]),\n    nsweeps = 10,\n    tolerance = 1e-5,\n)\n\n\n\n\n\n","category":"type"},{"location":"states/#Systems-and-States","page":"Systems and States","title":"Systems and States","text":"","category":"section"},{"location":"states/#Systems","page":"Systems and States","title":"Systems","text":"","category":"section"},{"location":"states/#TensorMixedStates.System","page":"Systems and States","title":"TensorMixedStates.System","text":"type System\n\nrepresent a quantum system\n\nFields\n\nsites::Vector{<:AbstractSite}: sites of the system\npure_indices::Vector{Index}: Indices for pure representations\nmixed_indices::Vector{Index}: Indices for mixed representations\n\nExamples\n\nSystem(10, Qubit())\nSystem([Qubit(), SpinOne(), Qubit(), Boson(5)])\n\nIndexation\n\nsystem[i]          gives site i\nsystem[Pure(), i]  gives pure index i\nsystem[Mixed(), i] gives mixed index i\n\n\n\n\n\n","category":"type"},{"location":"states/#Base.length-Tuple{System}","page":"Systems and States","title":"Base.length","text":"length(::System)\n\nreturn the number of sites in the system\n\n\n\n\n\n","category":"method"},{"location":"states/#NDTensors.sim-Tuple{System}","page":"Systems and States","title":"NDTensors.sim","text":"sim(::System)\n\ncreate a clone of the system: identical but with different indices\n\n\n\n\n\n","category":"method"},{"location":"states/#TensorMixedStates.:⊗-Tuple{System, System}","page":"Systems and States","title":"TensorMixedStates.:⊗","text":"::System ⊗ ::System\ntensor(::System, ::System)\n\ncreate the tensorial product of two systems\n\n\n\n\n\n","category":"method"},{"location":"states/#States","page":"Systems and States","title":"States","text":"","category":"section"},{"location":"states/#TensorMixedStates.Limits","page":"Systems and States","title":"TensorMixedStates.Limits","text":"A type to hold MPS limits\n\nFields\n\ncutoff: the cutoff under which singular values are neglected\nmaxdim: the maximum bond dimension\n\n\n\n\n\n","category":"type"},{"location":"states/#TensorMixedStates.State","page":"Systems and States","title":"TensorMixedStates.State","text":"struct State\nState(Pure()|Mixed(), ::System, states)\nState(Pure()|Mixed(), ::Int, ::AbstractSite, state)\nState(Pure()|Mixed(), ::Vector{<:AbstractSite}, state)\nState(::State, ::MPS)\n\nrepresent the complete state of the simulated quantum system\n\nFields\n\ntype::Union{Pure, Mixed}: pure or mixed representation\nsystem::System: system description\nstate::MPS: system state\npreobs::PreObs: preprocessing data for computing observables\n\nExamples\n\nState(Pure(), system, \"Up\")\nState(Mixed(), system, [\"Up\", \"Dn\", \"Up\"])\nState(Mixed(), system, \"FullyMixed\")\nState(Pure(), system, [1, 0])\nState(Pure(), 10, Qubit(), \"Up\")\nState(Mixed(), [Qubit(), Boson(4), Fermion()], [\"Up\", \"2\", \"Occ\"])\nState(state, mps)        returns a new state with the same system but a new mps\n\nOperations\n\nstates can be added, substracted and multiplied by numbers\n\n\n\n\n\n","category":"type"},{"location":"states/#Base.length-Tuple{State}","page":"Systems and States","title":"Base.length","text":"length(::State)\n\nreturn the number of sites in the state\n\n\n\n\n\n","category":"method"},{"location":"states/#ITensorMPS.maxlinkdim-Tuple{State}","page":"Systems and States","title":"ITensorMPS.maxlinkdim","text":"maxlinkdim(::State)\n\nreturn the maximum link dimension in the state\n\n\n\n\n\n","category":"method"},{"location":"states/#TensorMixedStates.mix-Tuple{State}","page":"Systems and States","title":"TensorMixedStates.mix","text":"mix(::State)\n\ntransform a pure representation into a mixed representation\n\n\n\n\n\n","category":"method"},{"location":"states/#Base.truncate-Tuple{State}","page":"Systems and States","title":"Base.truncate","text":"truncate(::State; limits::Limits)\n\napply the truncation to the given state\n\n\n\n\n\n","category":"method"},{"location":"states/#TensorMixedStates.trace-Tuple{State}","page":"Systems and States","title":"TensorMixedStates.trace","text":"trace(::State)\n\nReturn the trace of the system, mostly usefull for mixed representations. This should be one.\n\n\n\n\n\n","category":"method"},{"location":"states/#TensorMixedStates.trace2-Tuple{State}","page":"Systems and States","title":"TensorMixedStates.trace2","text":"trace2(::State)\n\nReturn the trace of the square density matrix, mostly usefull for mixed representations. This is one for pure representations.\n\n\n\n\n\n","category":"method"},{"location":"states/#LinearAlgebra.norm-Tuple{State}","page":"Systems and States","title":"LinearAlgebra.norm","text":"norm(::State)\n\nReturn the norm of the state, mostly usefull for pure representations. This should be one for pure representation.\n\n\n\n\n\n","category":"method"},{"location":"states/#ITensors.dag-Tuple{State}","page":"Systems and States","title":"ITensors.dag","text":"dag(::State)\n\nadjoint of density matrix for mixed representation\n\n\n\n\n\n","category":"method"},{"location":"states/#TensorMixedStates.symmetrize-Tuple{State}","page":"Systems and States","title":"TensorMixedStates.symmetrize","text":"symmetrize(::State)\n\nsymmetrize state so that it is hermitian (only for mixed state)\n\n\n\n\n\n","category":"method"},{"location":"states/#TensorMixedStates.hermitianity-Tuple{State}","page":"Systems and States","title":"TensorMixedStates.hermitianity","text":"hermitianity(::State)\n\nhermitianity measure whether density matrix for mixed state is Hermitian as it should.\n\nreturn a value from 0 (anti Hermitian) to 1 (Hermitian)\n\nreturn 1 for pure state\n\n\n\n\n\n","category":"method"},{"location":"states/#TensorMixedStates.normsym","page":"Systems and States","title":"TensorMixedStates.normsym","text":"normsym(::State)\n\nequivalent to normalize(symmetrize(state))\n\n\n\n\n\n","category":"function"},{"location":"states/#TensorMixedStates.random_state","page":"Systems and States","title":"TensorMixedStates.random_state","text":"random_state(Pure()|Mixed(), ::System, linkdims::Int)\nrandom_state(Pure()|Mixed(), ::Int, ::AbstractSite, linkdims::Int)\nrandom_state(Pure()|Mixed(), ::Vector{<:AbstractSite}, linkdims::Int)\nrandom_state(Pure()|Mixed(), ::State, linkdims::Int)\n\nReturn a random state, with the specified link dimension. If a State is given, randomize the given state.\n\n\n\n\n\n","category":"function"},{"location":"states/#TensorMixedStates.partial_trace-Tuple{State, Vector{Int64}}","page":"Systems and States","title":"TensorMixedStates.partial_trace","text":"partial_trace(::State, ::Vector{Int} [; keepers = true])\n\nreturn the state partially traced at the given positions, alternatively one can give the positions to keep by setting keepers = true\n\n\n\n\n\n","category":"method"},{"location":"states/#Simulations","page":"Systems and States","title":"Simulations","text":"","category":"section"},{"location":"states/#TensorMixedStates.Simulation","page":"Systems and States","title":"TensorMixedStates.Simulation","text":"Simulation(state[, time = 0])\nSimulation(sim, state[, time = sim.time])\n\nA type to represent simulation data ans store time and file data. It is used and returned by runTMS. The first form creates a simulation object. The second updates the state in the simulation object. (see also get_sim_file)\n\nMost functions applicable to States can be applied to Simulations\n\nFields\n\nstate       : the state of the system\ntime        : the simulation time\noutput      : if not nothing an io where to redirect output\nfiles       : a dictionary holding io or dict where to write data\ndata        : a dictionary holding data collected for the Data objects\nformats     : format info for the output\n\n\n\n\n\n","category":"type"},{"location":"states/#TensorMixedStates.get_sim_file","page":"Systems and States","title":"TensorMixedStates.get_sim_file","text":"get_sim_file(::Simulation, filename)\n\nreturn the corresponding file of the given simulation \"stdout\" (or \"-\"), \"stderr\" and \"\" respectively redirect to stdout, stderr and devnull, other names are interpreted as file names.\n\nFilename finishing by \".json\" will return a Dict where to store data and this data will be output in JSON format in the file by runTMS at the end.\n\nSpecial filenames of the form Data(name) return a Dict where to store Data. Those Dict are gathered as a Dict in the data field of the Simulation\n\n\n\n\n\n","category":"function"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TensorMixedStates (TMS) is a Julia library to make simulations of closed or open quantum systems using Matrix Product States representations.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TMS uses Matrix Product State representations for the density matrix of the system. It proposes a large set of features: manipulations of systems and states, a rich set of sites and operators easily extensible by the user, powerful algorithms: computation of ground states using DMRG, Hamiltonian and Lindbladian evolution with TDVP (and others), applications of gates (including noisy gates).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Being based on ITensor, TMS delivers high performance computations and naturally runs in parallel.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The interface is user friendly. In particular, it features a very expressive syntax for operators allowing easy definitions of operators such as observables, gates, Hamiltonians or Lindbladians. Moreover the optional high level interface allows the writing of simple simulations in a few lines of code.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To cite this software, please cite the following reference article","category":"page"},{"location":"","page":"Home","title":"Home","text":"TensorMixedStates: A Julia library for simulating pure and mixed quantum states using matrix product states","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To use TMS, you need to have Julia installed on your system. Installing julia is usually esay and fast, see The Julia Programming Language for instructions. TMS requires at least Julia version 1.10.5 to run.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To install TMS in Julia, launch the Julia interface (by typing 'julia' on the command line) and type","category":"page"},{"location":"","page":"Home","title":"Home","text":"]add TensorMixedStates","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note the \"]\" required to enter julia package management system.","category":"page"},{"location":"","page":"Home","title":"Home","text":"After downloading TMS, Julia will automatically compile and install it. This process usually takes a couple of minutes and does not require interactions on your part.","category":"page"},{"location":"#Using-TMS","page":"Home","title":"Using TMS","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To use TMS in your code you need to write","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TensorMixedStates","category":"page"},{"location":"","page":"Home","title":"Home","text":"Julia script names are usually written with a .jl extension. Once you have written your script, you can execute it with","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia my_script.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"to run it on a single processor, or","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --threads=4 my_script.jl\njulia --threads=auto my_script.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"to use multi-threading (see julia documentation for more details on multi-threading).","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can also use TMS in the interactive julia interpreter.","category":"page"},{"location":"#Bug-reports-and-features-requests","page":"Home","title":"Bug reports and features requests","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"TMS is still in development and certainly contains bugs. If you think you have found one please report it on the Github page.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Features requests may also be sent on the Github page.","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Your are currently reading it!","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can have access to inline documentation on TMS at the julia prompt simply by typing \"?\" followed by the function name or type name you are interested in. For example","category":"page"},{"location":"","page":"Home","title":"Home","text":"?runTMS","category":"page"},{"location":"","page":"Home","title":"Home","text":"For this to work you must have first imported TMS with","category":"page"},{"location":"","page":"Home","title":"Home","text":"using TensorMixedStates","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Examples of working scripts are presented in the folder examples in the repository. ","category":"page"},{"location":"measurements/#Measurements","page":"Measurements","title":"Measurements","text":"","category":"section"},{"location":"measurements/#measure","page":"Measurements","title":"measure","text":"","category":"section"},{"location":"measurements/#TensorMixedStates.measure","page":"Measurements","title":"TensorMixedStates.measure","text":"measure(state, args[, t])\nmeasure(state, measure[, t])\nmeasure(state, [measures...][, t])\n\ncompute the requested measurements on the given state and simulation time\n\nIt is more efficient to ask all required measurements in one call\n\nExamples\n\nmeasure(state, X(1))     # compute observable X(1)\nmeasure(state, X)        # compute observable X on all sites\nmeasure(state, (X, Y))   # compute correlations XY on all pairs of sites\nmeasure(state, Check(\"check\", X(1)X(2), t->sin(2t)), 0.8) # compute and check the given observable against a computed value\nmeasure(state, [X(2), Y, (X, Y)]) # several measures together\n\n\n\n\n\n","category":"function"},{"location":"measurements/#TensorMixedStates.StateFunc","page":"Measurements","title":"TensorMixedStates.StateFunc","text":"struct StateFunc\nStateFunc(name, obs)\n\na data type to represent a function of State. This is used by measure.\n\n\n\n\n\n","category":"type"},{"location":"measurements/#TensorMixedStates.Check","page":"Measurements","title":"TensorMixedStates.Check","text":"struct Check\nCheck(name, obs1, obs2[, tol])\n\na measurement that checks the equality between two measurements. It throws an error if the difference is larger than tol.\n\n\n\n\n\n","category":"type"},{"location":"measurements/#TensorMixedStates.Measure","page":"Measurements","title":"TensorMixedStates.Measure","text":"struct Measure\nMeasure(args...)\n\na data type to hold a set of measurements, used internally\n\n\n\n\n\n","category":"type"},{"location":"measurements/#ITensorMPS.expect","page":"Measurements","title":"ITensorMPS.expect","text":"expect(::State, obs)\n\nCompute expectation values of obs on the given state.\n\nExamples\n\nexpect(state, X(1)*Y(2) + Y(1)*Z(3))\nexpect(state, [X(1)*Y(2), X(3), Z(1)*X(2)])\n\n\n\n\n\n","category":"function"},{"location":"measurements/#TensorMixedStates.expect1","page":"Measurements","title":"TensorMixedStates.expect1","text":"expect1(::State, op)\n\nCompute the expectation values of the given operators on all sites.\n\nExamples\n\nexpect1(state, X)\nexpect1(state, [X, Y, Z])\n\n\n\n\n\n","category":"function"},{"location":"measurements/#TensorMixedStates.expect2","page":"Measurements","title":"TensorMixedStates.expect2","text":"expect2(::State, op_pairs)\n\nCompute the expectation values of the given pairs of operators on all sites.\n\nExamples\n\nexpect2(state, (X, X))\nexpect2(state, [(X, Y), (X, Z), (Y, Z)])\n...\n\n\n\n\n\n","category":"function"},{"location":"measurements/#TensorMixedStates.entanglement_entropy","page":"Measurements","title":"TensorMixedStates.entanglement_entropy","text":"entanglement_entropy(::State, ::Int)\n\nReturn the entanglement entropy of the given state at the given site. Also return the associated spectrum.\n\n\n\n\n\n","category":"function"},{"location":"measurements/#Types-of-measurements","page":"Measurements","title":"Types of measurements","text":"","category":"section"},{"location":"measurements/","page":"Measurements","title":"Measurements","text":"There are five types of measurements we can ask to measure","category":"page"},{"location":"measurements/","page":"Measurements","title":"Measurements","text":"With an indexed operator, we get the expectation of the corresponding observable","category":"page"},{"location":"measurements/","page":"Measurements","title":"Measurements","text":"mesure(state, X(1)X(2)Z(4))","category":"page"},{"location":"measurements/","page":"Measurements","title":"Measurements","text":"With a generic operator (acting on one site only), we get the expectation of the operator on each site","category":"page"},{"location":"measurements/","page":"Measurements","title":"Measurements","text":"measure(state, X)","category":"page"},{"location":"measurements/","page":"Measurements","title":"Measurements","text":"With a couple of generic operators, we get the correlation matrix of those observators","category":"page"},{"location":"measurements/","page":"Measurements","title":"Measurements","text":"measure(state, (X, Y))","category":"page"},{"location":"measurements/","page":"Measurements","title":"Measurements","text":"There are a some state functions predefined:","category":"page"},{"location":"measurements/","page":"Measurements","title":"Measurements","text":"measure(state, Trace)              # returns the trace of the state\nmeasure(state, Trace2)             # returns the trace of the square of the state (alternate name: Purity)\nmeasure(state, TraceError)         # returns 1 - trace, usefull for monitoring trace deviations\nmeasure(state, EE(l, n))           # returns entanglement entropy at site n and first n singular values\nmeasure(state, Hermitianity)       # returns 1 if density matrix is really Hermitian and down to 0 for anti Hermitian density matrix\nmeasure(state, HermitianityError)  # return 1 - Hermitianity for monitoring hermitianity deviation","category":"page"},{"location":"measurements/","page":"Measurements","title":"Measurements","text":"New state functions may be defined by","category":"page"},{"location":"measurements/","page":"Measurements","title":"Measurements","text":"stfunc = StateFunc(name, state->... )","category":"page"},{"location":"measurements/","page":"Measurements","title":"Measurements","text":"Checks can be performed (useful for coherence tests)","category":"page"},{"location":"measurements/","page":"Measurements","title":"Measurements","text":"measure(state, Check(name, obs1, obs2))      # returns 3 values ob1, obs2 and |obs2 - obs1|\nmessure(state, Check(name, obs1, obs2, tol)) # if |obs2 - obs1|>tol throw an error\nmeasure(state, Check(name, obs1, obs2), t)","category":"page"},{"location":"measurements/","page":"Measurements","title":"Measurements","text":"In Check, obs may also be constants, vectors and function of time (like t -> sin(t)), in this case the simulation time must be fed to measure as 3rd argument.","category":"page"},{"location":"measurements/#Output","page":"Measurements","title":"Output","text":"","category":"section"},{"location":"measurements/#TensorMixedStates.output","page":"Measurements","title":"TensorMixedStates.output","text":"output(::Simulation, [ filename => measure1, ... ])\n\ncompute the given measurements on a simultation and output them to the associated file or dict\n\nfilenames are interpreted by get_sim_file (see there for special values)\n\nExamples\n\noutput(sim, \"file\" => [X, X(1)Y(2), (X, Y)])\noutput(sim, [ \"file1\" => [X, Y(2)], \"file2\" => Trace])\n\n\n\n\n\n","category":"function"},{"location":"measurements/#TensorMixedStates.log_msg","page":"Measurements","title":"TensorMixedStates.log_msg","text":"log_msg(::Simulation, text)\n\nlog the given message on the \"log\" file of the simulation\n\n\n\n\n\n","category":"function"},{"location":"algorithms/#Algorithms","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"algorithms/#Ground-state-computation","page":"Algorithms","title":"Ground state computation","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Using DMRG, we can compute ground states for States and Simulations","category":"page"},{"location":"algorithms/#ITensorMPS.dmrg","page":"Algorithms","title":"ITensorMPS.dmrg","text":"dmrg(hamiltonian, ::State; options...)\ndmrg(hamiltonian, ::Simulation; options...)\n\noptimize for ground state of the given Hamiltonian starting with state / simulation using dmrg.\n\nNote that Dmrg does not work for mixed representations.\n\nOptions\n\nnsweeps: number of sweeps\nobserver!: observer (see DmrgObserver)\nlimits: constraints on the mps (cutoff and `maxdim may be vectors with different values for each sweep)\nothers identical to ITensorMPS.dmrg\n\n\n\n\n\n","category":"function"},{"location":"algorithms/#TensorMixedStates.DmrgObserver","page":"Algorithms","title":"TensorMixedStates.DmrgObserver","text":"struct DmrgObserver\nDmrgObserver(sim, measurements, period, tol)\n\nan observer for dmrg which makes and outputs measurements every period steps and stops it when energy improvements are smaller than tol\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#Time-evolution","page":"Algorithms","title":"Time evolution","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Using TDVP or ApproxW, we can do time evolution (Hamiltonian or Lindbladian)","category":"page"},{"location":"algorithms/#ITensorMPS.tdvp","page":"Algorithms","title":"ITensorMPS.tdvp","text":"tdvp(evolver, t, ::State; options...)\ntdvp(evolver, t, ::Simulation; options...)\n\ndo time evolution with tdvp algorithm on a state / sim for the given time t. Also see TdvpObserver\n\nOptions\n\nnsweeps: number sweeps to do (time step = t / nsweeps) \ncoefs: coefficients for time dependent evolver\nn_expand: do expansion steps every n_expand steps (default 0 means no expansion)\nn_symmetrize: make hermitian (for mixed states) every n_symmetrize steps (default 0 for no corrections)\nothers are identical to ITensorMPS.tdvp\n\n\n\n\n\n","category":"function"},{"location":"algorithms/#TensorMixedStates.approx_W","page":"Algorithms","title":"TensorMixedStates.approx_W","text":"approx_W(evolver, t, ::State; options...)\napprox_W(evolver, t, ::Simulation; options...)\n\ntime evolution using approximation WI or WII at a given order. Also see ApproxWObserver\n\nOptions\n\ncoefs: coefficients for time dependent evolution\nn_symmetrize: make hermitian (for mixed states) every n_symmetrize steps (default 0 for no corrections)\nnsweeps: number of steps (time step is t / nsweeps)\norder: order of approximation\nw: 1 or 2 for WI or WII\nobserver!: observer (see ApproxWObserver)\ntime_start: the simulation time at the beginning of evolution\nlimits: MPS constraints\n\n\n\n\n\n","category":"function"},{"location":"algorithms/#TensorMixedStates.TdvpObserver","page":"Algorithms","title":"TensorMixedStates.TdvpObserver","text":"struct TdvpObserver\nTdvpObserver(sim, measurements, period)\n\nan observer for tdvp which make measurements every period steps\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#TensorMixedStates.ApproxWObserver","page":"Algorithms","title":"TensorMixedStates.ApproxWObserver","text":"struct ApproxWObserver\nApproxWObserver(sim, measurements, period)\n\nan observer for approx_W which make measurements every period steps\n\n\n\n\n\n","category":"type"},{"location":"algorithms/#Gate-application","page":"Algorithms","title":"Gate application","text":"","category":"section"},{"location":"algorithms/#ITensors.apply","page":"Algorithms","title":"ITensors.apply","text":"apply(op, ::State; limits::Limits)\napply(mps, ::State; limits::Limits)\napply(op, ::Simulation; limits::Limits)\n\nApply the given gates to the state and truncate the result according to limits. It is much more efficient to apply all the gates in a single call to apply.\n\nExamples\n\napply(CZ(1,3)*H(2)*CNOT(3,4), state)\n\n\n\n\n\n","category":"function"}]
}
