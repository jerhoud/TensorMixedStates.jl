<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Manual · TensorMixedStates</title><meta name="title" content="Manual · TensorMixedStates"/><meta property="og:title" content="Manual · TensorMixedStates"/><meta property="twitter:title" content="Manual · TensorMixedStates"/><meta name="description" content="Documentation for TensorMixedStates."/><meta property="og:description" content="Documentation for TensorMixedStates."/><meta property="twitter:description" content="Documentation for TensorMixedStates."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="TensorMixedStates logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">TensorMixedStates</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Manual</a><ul class="internal"><li><a class="tocitem" href="#Import"><span>Import</span></a></li><li><a class="tocitem" href="#Sites-and-Systems"><span>Sites and Systems</span></a></li><li><a class="tocitem" href="#States"><span>States</span></a></li><li><a class="tocitem" href="#Limits"><span>Limits</span></a></li><li><a class="tocitem" href="#Operators"><span>Operators</span></a></li><li><a class="tocitem" href="#Algorithms"><span>Algorithms</span></a></li><li><a class="tocitem" href="#Measurements"><span>Measurements</span></a></li><li><a class="tocitem" href="#High-Level-Interface"><span>High Level Interface</span></a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../sites/">Sites</a></li><li><a class="tocitem" href="../operators/">Operators</a></li><li><a class="tocitem" href="../states/">Systems and States</a></li><li><a class="tocitem" href="../algorithms/">Algorithms</a></li><li><a class="tocitem" href="../measurements/">Measurements</a></li><li><a class="tocitem" href="../highlevel/">High level interface</a></li><li><a class="tocitem" href="../others/">Others</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Manual</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Manual</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jerhoud/TensorMixedStates.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jerhoud/TensorMixedStates.jl/blob/main/docs/src/manual.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Manual"><a class="docs-heading-anchor" href="#Manual">Manual</a><a id="Manual-1"></a><a class="docs-heading-anchor-permalink" href="#Manual" title="Permalink"></a></h1><h2 id="Import"><a class="docs-heading-anchor" href="#Import">Import</a><a id="Import-1"></a><a class="docs-heading-anchor-permalink" href="#Import" title="Permalink"></a></h2><p>To use TMS, you must first import it with</p><pre><code class="nohighlight hljs">using TensorMixedStates</code></pre><h2 id="Sites-and-Systems"><a class="docs-heading-anchor" href="#Sites-and-Systems">Sites and Systems</a><a id="Sites-and-Systems-1"></a><a class="docs-heading-anchor-permalink" href="#Sites-and-Systems" title="Permalink"></a></h2><p>The first step in using TMS is the definition of your quantum system. In TMS, a system is composed of a finite number of sites numbered from 1 (1, 2, ..., N). These sites may be all identical or not.</p><p>There are seven different predefined types of site: <code>Qubit</code>, <code>Fermion</code>, <code>Boson</code>, <code>Spin</code>, <code>Electron</code>, <code>Tj</code> and <code>Qboson</code>.</p><p>To use each of these sites and the corresponding predefined operators you need first to import the corresponding module. For example to use qubits, you need to write</p><pre><code class="nohighlight hljs">using .Qubits</code></pre><p>Note the &quot;.&quot; before the name and the &quot;s&quot; at the end.</p><p>To define a site just call the corresponding creator for example</p><pre><code class="nohighlight hljs">s = Qubit()</code></pre><p>Some site creators need arguments: <code>Boson</code> (for the maximum occupancy) and <code>Spin</code>, for example</p><pre><code class="nohighlight hljs">s = Boson(4)
s = Spin(3/2)</code></pre><p>You can now define a quantum system by declaring the sites it contains:</p><pre><code class="nohighlight hljs">system1 = System(10, Qubit())</code></pre><p>gives you a system with 10 qubits. Systems may have different types of site, in this case you must feed <code>System</code> with an array of sites</p><pre><code class="nohighlight hljs">system2 = System([Qubit(), Boson(4), Fermion()])</code></pre><p>gives you a three site system.</p><h2 id="States"><a class="docs-heading-anchor" href="#States">States</a><a id="States-1"></a><a class="docs-heading-anchor-permalink" href="#States" title="Permalink"></a></h2><p>States may be in pure or mixed representation, these two possibilities are represented in TMS, by <code>Pure()</code> or <code>Mixed()</code> (note the parenthesis).</p><p>To create a state, we call the State creator</p><pre><code class="nohighlight hljs">state1 = State(Pure(), system1, &quot;Up&quot;)</code></pre><p>returns a pure up state in a 10 qubit system. Predefined local states are designated by there name. Here <code>&quot;Up&quot;</code> is a predefined state of site <code>Qubit</code>.</p><p>All sites need not be all in the same local states, in which case we give State an array of local states</p><pre><code class="nohighlight hljs">state2 = State(Mixed(), system2, [&quot;+&quot;, &quot;2&quot;, &quot;Occ&quot;])</code></pre><p>Here we chose a mixed representation.</p><p>States may be added or multiplied by a number (they need to be based on the same system). For example</p><pre><code class="nohighlight hljs">ghz = (State(Pure(), system1, &quot;Up&quot;) + State(Pure(), system1, &quot;Dn&quot;)) / 2</code></pre><p>We can transform a pure representation into a mixed representation by</p><pre><code class="nohighlight hljs">mixedstate = mix(purestate)</code></pre><p>For mixed states there is a local mixed state <code>&quot;FullyMixed&quot;</code> which correspond to a density matrix proportional to the identity matrix.</p><p>If you need a local state which is not predefined, it is possible to pass its vector (or matrix for mixed states) directly, For example, we could also define <code>state1</code> by</p><pre><code class="nohighlight hljs">state1 = State(Pure(), system1, [1., 0.])</code></pre><h2 id="Limits"><a class="docs-heading-anchor" href="#Limits">Limits</a><a id="Limits-1"></a><a class="docs-heading-anchor-permalink" href="#Limits" title="Permalink"></a></h2><p>TMS uses Matrix Product State to internally represent quantum states. It is important to control the parameters of this approximation, in particular the maximum bond dimension and the cutoff on singular values. To achieve this, many functions accept a <code>Limits</code> object as keyword argument containing those parameters. It is build thus</p><pre><code class="nohighlight hljs">lim = Limits(cutoff = 1e-10, maxdim = 50)</code></pre><p>each (or both) of the arguments may be omitted in which case it corresponds to an absence of constraint for this parameter. In particular, <code>Limits()</code> represents no constraint.</p><p>To apply the constraints on a state, one uses</p><pre><code class="nohighlight hljs">newstate = truncate(oldstate; limits = lim)</code></pre><p>Many functions accept such an argument. For example, when adding states instead of</p><pre><code class="nohighlight hljs">state = (state1 + state2) / 2</code></pre><p>One can write</p><pre><code class="nohighlight hljs">state = +(state1, state2; limits = lim) / 2</code></pre><h2 id="Operators"><a class="docs-heading-anchor" href="#Operators">Operators</a><a id="Operators-1"></a><a class="docs-heading-anchor-permalink" href="#Operators" title="Permalink"></a></h2><p>In TMS, there are two kinds of operators: generic operators and indexed operators. For example,</p><pre><code class="nohighlight hljs">X</code></pre><p>represents the <span>$\sigma_x$</span> Pauli operator for qubits. This is a <em>generic operator</em>, it is not applied to a specific site.</p><pre><code class="nohighlight hljs">X(3)</code></pre><p>represents the <span>$\sigma_x$</span> Pauli operator applied to the system site number 3. This is an <em>indexed operator</em>.</p><p>Note that all predefined operator names start with a capital letter, so it is better to keep your own identifiers lowercase to prevent name collisions.</p><p>The operator system is very rich and flexible. For example, if you want to use this Hamiltonian</p><p class="math-container">\[H = \sum_{i=1}^{n-1} \sigma_x(i) \sigma_x(i+1)\]</p><p>you will simply write</p><pre><code class="nohighlight hljs">h = sum(X(i)X(i+1) for i in 1:n-1)</code></pre><p>Many operations are defined on generic operators:</p><ul><li>addition, multiplication and power by a number</li><li>tensor product: <code>X⊗X</code> is a two site operator (one can also write <code>tensor(X, X)</code>)</li><li><code>dag</code> represents the adjoint operator, for example <code>C</code> is the <code>c</code> operator for fermions and <code>dag(C)</code> is <span>$c^\dagger$</span>.</li><li><code>Dissipator</code> represents a Lindblad dissipator, for example <code>Dissipator(Sp)</code> is the jump operator that may flip a qubit toward up (<code>Sp</code> is the <span>$S^+$</span> operator)</li><li><code>Gate</code> represents an operator to be applied as a gate on a mixed state. It is useful to define noisy gate operators, for example <code>0.9 Gate(Id) + 0.1 Gate(X)</code> is a noisy gate operator that will apply an <span>$\sigma_x$</span> gate 10 percent of the time.</li><li><code>Proj</code> represents an operator that projects on the given state, for example <code>Proj(&quot;Up&quot;)</code> projects qubits on the up state.</li><li>the functions <code>exp</code> and <code>sqrt</code>: for example <code>sqrt(Swap)</code></li><li><code>controlled</code> for qubits makes controlled gates: <code>CX = controlled(X)</code></li></ul><p>For example one can define the Rxy 2-site operator by</p><pre><code class="nohighlight hljs">Rxy(t) = exp(-im * t * (X⊗X + Y⊗Y) / 4)</code></pre><p>If this is not enough to define your favorite operator you can create new ones by specifying their matrix</p><pre><code class="nohighlight hljs">myop = Operator(&quot;MyOp&quot;, [1 1 ; 1 -1] / √2)</code></pre><p>For multiple site or mixed operators you must specify the type</p><pre><code class="nohighlight hljs">Swap = Operator{Pure, 2}(&quot;Swap&quot;, [1 0 0 0 ; 0 0 1 0 ; 0 1 0 0 ; 0 0 0 1])</code></pre><p>Finally from generic operators, we define indexed operators by simply applying them to the corresponding sites</p><pre><code class="nohighlight hljs">Rxy(0.2)(2, 5)
myop(3)
Swap(4, 7)</code></pre><p>In the case of Hamiltonian or Lindbladian evolution the Hamiltonian part is to be multiplied by -im:</p><pre><code class="nohighlight hljs">evolver = -im * hamiltonian + dissipators</code></pre><h2 id="Algorithms"><a class="docs-heading-anchor" href="#Algorithms">Algorithms</a><a id="Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms" title="Permalink"></a></h2><p>We can now work with states and operators.</p><p>We can apply gates with <code>apply</code></p><pre><code class="nohighlight hljs">newstate = apply(gates, oldstate; limits)</code></pre><p>the <code>gates</code> argument is an indexed operator representing the gates to apply</p><p>the keyword argument limits fixes the constraints to apply</p><p>We can compute ground states with <code>dmrg</code></p><pre><code class="nohighlight hljs">groundstate, energy = dmrg(hamiltonian, startstate; options...)</code></pre><p>the options are <code>limits</code> to set constraints and <code>nsweeps</code> to fix the number of sweeps among others.</p><p>We can do time evolution with <code>tdvp</code> and <code>approx_W</code></p><pre><code class="nohighlight hljs">newstate = tdvp(evolver, time, oldstate; options...)
newstate = approx_W(evolver, time, oldstate; options...)</code></pre><p>the options are <code>limits</code> for the constraints, <code>nsweeps</code> for the number of step to do and for <code>approx_W</code>, <code>order</code> and <code>w</code> for the parameters of the algorithm (<code>order = 4, w = 2</code> are usually good)</p><p>For more details, see the reference or the inline help.</p><h2 id="Measurements"><a class="docs-heading-anchor" href="#Measurements">Measurements</a><a id="Measurements-1"></a><a class="docs-heading-anchor-permalink" href="#Measurements" title="Permalink"></a></h2><p>Once we have created a state, we may want to measure it.</p><pre><code class="nohighlight hljs">result = measure(state, X(1)X(3))</code></pre><p>will give <span>$\langle \psi | \sigma_x^1 \sigma_x^3 | \psi \rangle$</span></p><pre><code class="nohighlight hljs">result = measure(state, X)</code></pre><p>will give the array of the <span>$\langle \psi | \sigma_x^i | \psi \rangle$</span></p><pre><code class="nohighlight hljs">result = measure(state, (X, Y))</code></pre><p>will give the matrix of the <span>$\langle \psi | \sigma_x^i \sigma_y^j | \psi \rangle$</span></p><p>We can also measure other properties with <code>Trace</code>, <code>TraceError</code>, <code>Trace2</code>, <code>Purity</code>, <code>Hermitianity</code>, <code>HermitianityError</code>, <code>EE</code>, <code>Linkdim</code> and <code>MemoryUsage</code>.</p><p>We can also ask for several measurements at the same time</p><pre><code class="nohighlight hljs">results = measure(state, [X, X(2)Z(3), (X, Y), Trace, MemoryUsage])</code></pre><p>For more details see the reference or the inline help.</p><h2 id="High-Level-Interface"><a class="docs-heading-anchor" href="#High-Level-Interface">High Level Interface</a><a id="High-Level-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#High-Level-Interface" title="Permalink"></a></h2><h3 id="Framework"><a class="docs-heading-anchor" href="#Framework">Framework</a><a id="Framework-1"></a><a class="docs-heading-anchor-permalink" href="#Framework" title="Permalink"></a></h3><p>Most simulations follow the same pattern: start from some simple state, make some evolution and make measurements during or after the evolution and save the results to file. For these simple cases, TMS proposes a simpler interface.</p><p>A simple simulation follows a single state through a certain number of phases which act in a simple way on the state and make measurements during and/or after the evolution and save the results to file.</p><p>The following phases are available:</p><ul><li><code>CreateState</code> : create a simple state</li><li><code>DMRG</code> : compute the ground state (requires a pure state)</li><li><code>ToMixed</code> : go from pure representation to mixed representation</li><li><code>Evolve</code> : do Hamiltonian or Lindbladian evolution</li><li><code>Gates</code> : apply some gates</li><li><code>PartialTrace</code> : trace the system over some sites (requires a mixed state)</li><li><code>SteadyState</code> : compute the steady state of a Lindblad equation (requires a mixed state)</li></ul><p>with these phases we define a <code>SimData</code> object that describes the simulation and finally, we call</p><pre><code class="nohighlight hljs">runTMS(simdata)</code></pre><p>which executes the simulation.</p><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>As an example, here is the complete code for such a simple simulation:</p><pre><code class="nohighlight hljs">using TensorMixedStates, .Fermions

hamiltonian(n) = -sum(dag(C)(i)C(i+1)+dag(C)(i+1)C(i) for i in 1:n-1)
dissipators(n, gamma) = sum(Dissipator(sqrt(4gamma) * N)(i) for i in 1:n)

sim_data(n, gamma, step) = SimData(
    name = &quot;Fermion tight-binding chain with dephasing noise&quot;,
    phases = [
        CreateState(
            type = Mixed(),
            sytem = System(n, Fermion()),
            state = [ iseven(i) ? &quot;Occ&quot; : &quot;Emp&quot; for i in 1:n ]),
        Evolve(
            duration = 4,
            time_step = step,
            algo = Tdvp(),
            evolver = -im*hamiltonian(n) + dissipators(n, gamma),
            limits = Limits(cutoff = 1e-30, maxdim = 100),
            measures = [
                &quot;density.dat&quot; =&gt; N,
                &quot;OSEE.dat&quot; =&gt; EE(div(n, 2))
            ]
        )
    ]
)

runTMS(sim_data(40, 1., 0.05))</code></pre><h3 id="Output"><a class="docs-heading-anchor" href="#Output">Output</a><a id="Output-1"></a><a class="docs-heading-anchor-permalink" href="#Output" title="Permalink"></a></h3><p><code>runTMS</code> creates a directory named after the <code>SimData</code> object <code>name</code> field and puts the output files there. In particular, it produces a <code>log</code> file showing the progression of the computation, a <code>prog.jl</code> file containing a copy of the script, a <code>description</code> file containing the content of the <code>SimData</code> <code>description</code> field, a <code>stamp</code> file containing version and date info, a <code>running</code> empty file is present during the computation, in case of error an empty <code>error</code> file is created.</p><p>Three keyword arguments may be given <code>restart</code> (default <code>true</code>) erases the directory before starting, <code>clean</code> (default <code>false</code>) erases the directory and does not run the simulation, <code>output</code> (default <code>nothing</code>) if set, does not create the directory nor any output files an redirect all output to the given io channel (useful values are stdout and devnull). </p><p>Measurements are specified in the <code>measures</code> or <code>final_measures</code> fields. They take the form of a pair</p><pre><code class="nohighlight hljs">measures = destination =&gt; measurements</code></pre><p>or a list of pairs. The possible measurements are described in the measurements section of this manual. There are three types of destinations:</p><ul><li><p>filenames: writes the specified measurements to the given file as they are made. Special filenames are &quot;stdout&quot; (or &quot;-&quot;), &quot;stderr&quot;, &quot;&quot; (for devnull)</p><p>&quot;file.dat&quot; =&gt; X</p></li><li><p>json filenames: filenames ending by &quot;.json&quot; are treated differently: data is accumulated during the simulation and written at the end in the JSON format.</p><p>&quot;file.json&quot; =&gt; [Purity, X(2)Z(3), (X, Y)]</p></li><li><p>Data object: data is accumulated during the simulation and stored in the <code>data</code> field of the <code>Simulation</code> object returned by <code>runTMS</code>. This is useful for analyzing the data inside the program.</p><p>Data(&quot;mydata&quot;) =&gt; [TraceError, X(1), Y]</p></li></ul><p>The <code>DataToFrame</code> function can used on the result to get a <code>DataFrame</code> object (the user must import the <code>DataFrames</code> package himself before using this function)</p><pre><code class="nohighlight hljs">sim = runTMS(simdata)
df = DataToFrame(sim.data[&quot;mydata&quot;])</code></pre><p>For more information, see the reference or inline help for each phase, <code>SimData</code> and <code>runTMS</code>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../sites/">Sites »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.12.0 on <span class="colophon-date" title="Wednesday 11 June 2025 21:01">Wednesday 11 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
